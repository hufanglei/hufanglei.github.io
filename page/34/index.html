<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222"><meta name="generator" content="Hexo 7.3.0">

  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.7.2/css/all.min.css" integrity="sha256-dABdfBfUoC8vJUBOwGVdm8L9qlMWaHTIfXt+7GnZCIo=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/animate.css/3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous">

<script class="next-config" data-name="main" type="application/json">{"hostname":"hufanglei.github.io","root":"/","images":"/images","scheme":"Gemini","darkmode":false,"version":"8.22.0","exturl":false,"sidebar":{"position":"left","width_expanded":320,"width_dual_column":240,"display":"post","padding":18,"offset":12,"scrollpercent":true,"onmobile":false},"hljswrap":true,"copycode":{"enable":true,"style":null},"fold":{"enable":false,"height":500},"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"stickytabs":false,"motion":{"enable":true,"async":false,"duration":200,"transition":{"menu_item":"fadeInDown","post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"},"path":"/search.xml","localsearch":{"enable":true,"top_n_per_article":1,"unescape":false,"preload":false}}</script><script src="/js/config.js"></script>

    <meta name="description" content="直到这一刻微笑着说话为止，我至少留下了一公升眼泪">
<meta property="og:type" content="blog">
<meta property="og:title" content="个人博客">
<meta property="og:url" content="https://hufanglei.github.io/page/34/index.html">
<meta property="og:site_name" content="个人博客">
<meta property="og:description" content="直到这一刻微笑着说话为止，我至少留下了一公升眼泪">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="胡方雷">
<meta name="twitter:card" content="summary">


<link rel="canonical" href="https://hufanglei.github.io/page/34/">


<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":true,"isPost":false,"lang":"zh-CN","comments":"","permalink":"","path":"page/34/index.html","title":""}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>个人博客</title>
  








  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <div class="column">
      <header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏" role="button">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <h1 class="site-title">个人博客</h1>
      <i class="logo-line"></i>
    </a>
      <p class="site-subtitle" itemprop="description">记录生活中的点点滴滴</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger" aria-label="搜索" role="button">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a></li><li class="menu-item menu-item-about"><a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a></li><li class="menu-item menu-item-tags"><a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签<span class="badge">398</span></a></li><li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类<span class="badge">105</span></a></li><li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档<span class="badge">594</span></a></li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
      <div class="search-header">
        <span class="search-icon">
          <i class="fa fa-search"></i>
        </span>
        <div class="search-input-container">
          <input autocomplete="off" autocapitalize="off" maxlength="80"
                placeholder="搜索..." spellcheck="false"
                type="search" class="search-input">
        </div>
        <span class="popup-btn-close" role="button">
          <i class="fa fa-times-circle"></i>
        </span>
      </div>
      <div class="search-result-container">
        <div class="search-result-icon">
          <i class="fa fa-spinner fa-pulse fa-5x"></i>
        </div>
      </div>
    </div>
  </div>

</header>
        
  
  <aside class="sidebar">

    <div class="sidebar-inner sidebar-overview-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="胡方雷"
      src="/images/avatar.gif">
  <p class="site-author-name" itemprop="name">胡方雷</p>
  <div class="site-description" itemprop="description">直到这一刻微笑着说话为止，我至少留下了一公升眼泪</div>
</div>
<div class="site-state-wrap animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        <a href="/archives/">
          <span class="site-state-item-count">594</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
          <a href="/categories/">
        <span class="site-state-item-count">105</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
          <a href="/tags/">
        <span class="site-state-item-count">398</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author animated">
      <span class="links-of-author-item">
        <a href="https://github.com/hufanglei" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;hufanglei" rel="noopener me" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="https://hufanglei.blog.csdn.net/" title="CSDN → https:&#x2F;&#x2F;hufanglei.blog.csdn.net" rel="noopener me" target="_blank"><i class="crosshairs fa-fw"></i>CSDN</a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:690328661@qq.com" title="E-Mail → mailto:690328661@qq.com" rel="noopener me" target="_blank"><i class="fa fa-envelope fa-fw"></i>E-Mail</a>
      </span>
  </div>
  <div class="cc-license animated" itemprop="license">
    <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" class="cc-opacity" rel="noopener" target="_blank"><img src="https://cdnjs.cloudflare.com/ajax/libs/creativecommons-vocabulary/2020.11.3/assets/license_badges/small/by_nc_sa.svg" alt="Creative Commons"></a>
  </div>

        </div>
      </div>
    </div>

    <iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width=330 height=86 src="//music.163.com/outchain/player?type=2&id=1518938&auto=1&height=66"></iframe>

    
    <div class="sidebar-inner sidebar-blogroll">
      <div class="links-of-blogroll animated">
        <div class="links-of-blogroll-title">
          链接
        </div>
        <ul class="links-of-blogroll-list">
            <li class="links-of-blogroll-item">
              <a href="http://www.alloyteam.com/nav/" title="http:&#x2F;&#x2F;www.alloyteam.com&#x2F;nav&#x2F;" rel="noopener" target="_blank">Web前端导航</a>
            </li>
            <li class="links-of-blogroll-item">
              <a href="http://www.uisdc.com/" title="http:&#x2F;&#x2F;www.uisdc.com&#x2F;" rel="noopener" target="_blank">优设</a>
            </li>
            <li class="links-of-blogroll-item">
              <a href="http://www.zhangxinxu.com/" title="http:&#x2F;&#x2F;www.zhangxinxu.com&#x2F;" rel="noopener" target="_blank">牛人文档</a>
            </li>
            <li class="links-of-blogroll-item">
              <a href="http://ife.baidu.com/" title="http:&#x2F;&#x2F;ife.baidu.com&#x2F;" rel="noopener" target="_blank">百度前端技术学院</a>
            </li>
            <li class="links-of-blogroll-item">
              <a href="http://wf.uisdc.com/cn/" title="http:&#x2F;&#x2F;wf.uisdc.com&#x2F;cn&#x2F;" rel="noopener" target="_blank">google前端开发基础</a>
            </li>
        </ul>
      </div>
    </div>
  </aside>


    </div>

    <div class="main-inner index posts-expand">

    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://hufanglei.github.io/2020/01/01/%E8%BF%9B%E9%98%B6%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F(3)%20--%20%E9%80%82%E9%85%8D%E5%99%A8%E6%A8%A1%E5%BC%8F/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="胡方雷">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="个人博客">
      <meta itemprop="description" content="直到这一刻微笑着说话为止，我至少留下了一公升眼泪">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | 个人博客">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2020/01/01/%E8%BF%9B%E9%98%B6%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F(3)%20--%20%E9%80%82%E9%85%8D%E5%99%A8%E6%A8%A1%E5%BC%8F/" class="post-title-link" itemprop="url">进阶设计模式(3) -- 适配器模式</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2020-01-01 21:32:42" itemprop="dateCreated datePublished" datetime="2020-01-01T21:32:42+08:00">2020-01-01</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2025-01-24 11:37:59" itemprop="dateModified" datetime="2025-01-24T11:37:59+08:00">2025-01-24</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/" itemprop="url" rel="index"><span itemprop="name">设计模式</span></a>
        </span>
    </span>

  
    <span class="post-meta-break"></span>
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>58</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>1 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <span id="more"></span>

<p>@[toc]</p>
<h1 id="适配器模式"><a href="#适配器模式" class="headerlink" title="适配器模式"></a>适配器模式</h1><p><img src="https://raw.githubusercontent.com/hufanglei/img-csdn/main/img/2025-1-13/a1289c8c8f4806782ea0449652a0c57c_1737626683909.png" alt="在这里插入图片描述"></p>
<h2 id="1-初识适配器模式"><a href="#1-初识适配器模式" class="headerlink" title="1.初识适配器模式"></a>1.初识适配器模式</h2><p><img src="https://raw.githubusercontent.com/hufanglei/img-csdn/main/img/2025-1-13/7fd4c408160d77a4c72d7467fe3e1baf_1737626683909.png" alt="在这里插入图片描述"></p>
<h2 id="2-体会适配器模式"><a href="#2-体会适配器模式" class="headerlink" title="2.体会适配器模式"></a>2.体会适配器模式</h2><p><img src="https://raw.githubusercontent.com/hufanglei/img-csdn/main/img/2025-1-13/61081389bd9e1813b00f293d9d964dbb_1737626695974.png" alt="在这里插入图片描述"><br><img src="https://raw.githubusercontent.com/hufanglei/img-csdn/main/img/2025-1-13/633a643096629a58522119ac94e42d42_1737626695974.png" alt="在这里插入图片描述"><br><img src="https://raw.githubusercontent.com/hufanglei/img-csdn/main/img/2025-1-13/dfde7bebe5049597425c93fba4e83792_1737626695974.png" alt="在这里插入图片描述"><br><img src="https://raw.githubusercontent.com/hufanglei/img-csdn/main/img/2025-1-13/b529977c6639e5b9019b12fa956525d3_1737626695974.png" alt="在这里插入图片描述"><br><img src="https://raw.githubusercontent.com/hufanglei/img-csdn/main/img/2025-1-13/d24477cab4c69ffd8307ebeca1d10a6b_1737626695974.png" alt="在这里插入图片描述"></p>
<h2 id="3-理解适配器模式"><a href="#3-理解适配器模式" class="headerlink" title="3.理解适配器模式"></a>3.理解适配器模式</h2><p><img src="https://raw.githubusercontent.com/hufanglei/img-csdn/main/img/2025-1-13/fb82373b3d9aa1e087ceebc2731773cd_1737626708599.png" alt="在这里插入图片描述"><br><img src="https://raw.githubusercontent.com/hufanglei/img-csdn/main/img/2025-1-13/8aa1ea30201c9a0e4e7c8cf9c43d30fa_1737626708599.png" alt="在这里插入图片描述"><br><img src="https://raw.githubusercontent.com/hufanglei/img-csdn/main/img/2025-1-13/21a422ba581efc6d1ebef87c0e9415bb_1737626708599.png" alt="在这里插入图片描述"><br><img src="https://raw.githubusercontent.com/hufanglei/img-csdn/main/img/2025-1-13/a4b58f3518bd86df30822973e9335325_1737626708599.png" alt="在这里插入图片描述"><br><img src="https://raw.githubusercontent.com/hufanglei/img-csdn/main/img/2025-1-13/22307ddc9ee19c7fbfb7c973406e8872_1737626708599.png" alt="在这里插入图片描述"><br><img src="https://raw.githubusercontent.com/hufanglei/img-csdn/main/img/2025-1-13/bdb2435c387829fe965635a836777755_1737626721164.png" alt="在这里插入图片描述"><br><img src="https://raw.githubusercontent.com/hufanglei/img-csdn/main/img/2025-1-13/d730c1356b46a07abe021d43625f6293_1737626721164.png" alt="在这里插入图片描述"></p>
<h2 id="4-思考适配器模式"><a href="#4-思考适配器模式" class="headerlink" title="4.思考适配器模式"></a>4.思考适配器模式</h2><p><img src="https://raw.githubusercontent.com/hufanglei/img-csdn/main/img/2025-1-13/321fec514d9d5f6a6bf6fb8bc2153258_1737626721164.png" alt="在这里插入图片描述"></p>
<p>参考《研磨设计模式》</p>
<hr>
<p>完</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://hufanglei.github.io/2019/12/31/jvm(10)%20--%20%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D%E7%AD%96%E7%95%A5/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="胡方雷">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="个人博客">
      <meta itemprop="description" content="直到这一刻微笑着说话为止，我至少留下了一公升眼泪">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | 个人博客">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2019/12/31/jvm(10)%20--%20%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D%E7%AD%96%E7%95%A5/" class="post-title-link" itemprop="url">jvm(10) -- 内存分配策略</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2019-12-31 15:00:51" itemprop="dateCreated datePublished" datetime="2019-12-31T15:00:51+08:00">2019-12-31</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2025-01-24 11:37:59" itemprop="dateModified" datetime="2025-01-24T11:37:59+08:00">2025-01-24</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/jvm/" itemprop="url" rel="index"><span itemprop="name">jvm</span></a>
        </span>
    </span>

  
    <span class="post-meta-break"></span>
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>1.6k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>1 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <span id="more"></span>


<p>@[toc]</p>
<h1 id="内存分配策略"><a href="#内存分配策略" class="headerlink" title="内存分配策略"></a>内存分配策略</h1><h2 id="0-概述"><a href="#0-概述" class="headerlink" title="0.概述"></a>0.概述</h2><p><img src="https://raw.githubusercontent.com/hufanglei/img-csdn/main/img/2025-1-13/5302b6f0f59515bf2d5778ec2e18b55b_1737626721164.png" alt="在这里插入图片描述"></p>
<h2 id="1-内存分配优先进入eden区域"><a href="#1-内存分配优先进入eden区域" class="headerlink" title="1.内存分配优先进入eden区域"></a>1.内存分配优先进入eden区域</h2><p><img src="https://raw.githubusercontent.com/hufanglei/img-csdn/main/img/2025-1-13/d5cbb6ccfd8d7f475eafc3004c34d35e_1737626721164.png" alt="在这里插入图片描述"></p>
<blockquote>
<p><code>-verbose:gc -XX:+PrintGCDetails -XX:+UseSerialGC</code><br><img src="https://raw.githubusercontent.com/hufanglei/img-csdn/main/img/2025-1-13/4bcf62062e86d4d242cd72072968c29c_1737626732380.png" alt="在这里插入图片描述"></p>
</blockquote>
<blockquote>
<p>java -version</p>
</blockquote>
<p><img src="https://raw.githubusercontent.com/hufanglei/img-csdn/main/img/2025-1-13/d558635eeca3a03023f2db3c58d3cc4a_1737626732380.png" alt="在这里插入图片描述"><br>多核，2个G以上的cpu都认为是server vm。</p>
<p>操作1:</p>
<p><img src="https://raw.githubusercontent.com/hufanglei/img-csdn/main/img/2025-1-13/0ba0c252412efc3e30f76d10fff60f25_1737626732380.png" alt="在这里插入图片描述"></p>
<p>操作2:<br><img src="https://raw.githubusercontent.com/hufanglei/img-csdn/main/img/2025-1-13/20b85ddf2507877968664157dfaa26d6_1737626732380.png" alt="在这里插入图片描述"></p>
<p>说明大对象直接在老年代分配内存。</p>
<p>操作3:</p>
<p><img src="https://raw.githubusercontent.com/hufanglei/img-csdn/main/img/2025-1-13/3e30906fce084958f507e47f9a187da9_1737626732380.png" alt="在这里插入图片描述"><br>设置vm参数:</p>
<blockquote>
<p>-verbose:gc<br>-XX:+PrintGCDetails<br>-XX:+UseSerialGC<br>-Xms20M<br>-Xmx20M<br>-Xmn10M<br>-XX:SurvivorRatio&#x3D;8</p>
</blockquote>
<p><img src="https://raw.githubusercontent.com/hufanglei/img-csdn/main/img/2025-1-13/545be6ba3b930b1d21edbeeddcd9d04e_1737626744506.png" alt="在这里插入图片描述"><br>堆一共才20M大小，给他40M，肯定会内存溢出。</p>
<p>操作4:</p>
<p><img src="https://raw.githubusercontent.com/hufanglei/img-csdn/main/img/2025-1-13/71736ab68aab457a9b76727c17440f2e_1737626744506.png" alt="在这里插入图片描述"></p>
<p><img src="https://raw.githubusercontent.com/hufanglei/img-csdn/main/img/2025-1-13/ad300314d67fee46259c75ce8da5bebb_1737626744506.png" alt="在这里插入图片描述"></p>
<p>内存担保，eden区只能存8M，先存3个2M到eden，后面的4M来了，存不了，得放survior区，一个suvivior才1m，于是向老年代借空间，把原来的6m存在老年代。</p>
<p>这个4m根据eden优先原则，存在eden区。</p>
<h2 id="2-大对象直接进入老年代"><a href="#2-大对象直接进入老年代" class="headerlink" title="2.大对象直接进入老年代"></a>2.大对象直接进入老年代</h2><p>虚拟机提供了一个-XX:PretenureSizeThreshold参数，令大于这个设置值的对象直接在老年代分配。</p>
<p>PretenureSizeThreshold参数只对Serial和ParNew两款收集器有效，Parallel Scavenge收集器不认识这个参数，Parallel Scavenge收集器一般并不需要设置。如果遇到必须使用此参数的场合，可以考虑ParNew加CMS的收集器组合。</p>
<p>操作:</p>
<p>指定前:<br><img src="https://raw.githubusercontent.com/hufanglei/img-csdn/main/img/2025-1-13/dd76c00b3b1cd0bd67ceeb55093d0681_1737626744506.png" alt="在这里插入图片描述"><br><img src="https://raw.githubusercontent.com/hufanglei/img-csdn/main/img/2025-1-13/ad931f59fc7ae32257f848f417201c26_1737626744506.png" alt="在这里插入图片描述"></p>
<blockquote>
<p>指定多大内存到老年代<br><img src="https://raw.githubusercontent.com/hufanglei/img-csdn/main/img/2025-1-13/f832ccb31cce3c8ff6dfc07d025d4428_1737626755625.png" alt="在这里插入图片描述"><br><img src="https://raw.githubusercontent.com/hufanglei/img-csdn/main/img/2025-1-13/f46046cff815e068156335e1996cc35e_1737626755625.png" alt="在这里插入图片描述"></p>
</blockquote>
<h2 id="3-长期存活的对象直接进入老年代"><a href="#3-长期存活的对象直接进入老年代" class="headerlink" title="3.长期存活的对象直接进入老年代"></a>3.长期存活的对象直接进入老年代</h2><p><img src="https://raw.githubusercontent.com/hufanglei/img-csdn/main/img/2025-1-13/882240e4392a451f9c047e82ecf8e783_1737626755625.png" alt="在这里插入图片描述"><br><img src="https://raw.githubusercontent.com/hufanglei/img-csdn/main/img/2025-1-13/0ed1c10ddf4b3aab0b761ae031ed596e_1737626755625.png" alt="在这里插入图片描述"></p>
<p><img src="https://raw.githubusercontent.com/hufanglei/img-csdn/main/img/2025-1-13/db5a3c33a3652eafb9b87136e86d2ef0_1737626755625.png" alt="在这里插入图片描述"><br>通过上面的参数设置，到底多大的年龄进入老年代。</p>
<h2 id="4-空间分配担保"><a href="#4-空间分配担保" class="headerlink" title="4.空间分配担保"></a>4.空间分配担保</h2><p>在发生Minor GC 之前，虚拟机会先检查老年代最大可用连续空间是否大于新生代所有对象大小总和，如果条件成立，那么Minor GC可以确保是安全的。如果不成立，虚拟机会查看HandlePromotionFailure设置的值是否允许担保失败。如果允许，那么虚拟机会检查老年代最大可用连续空间是否大于历次晋升到老年代对象大小的平均值，如果大于，将会尝试进行一次Minor GC；如果小于，或者HandlePromotionFailure设置不允许冒险，这时会进行一次Full GC。</p>
<p>JDK 6 Update 24 之后，HandlePromotionFailure参数不会再影响到虚拟机空间分配担保的策略，规则变为只要老年代的连续空间大于新生代对象总大小或者大于历次晋升对象大小的平均值就会进行Minor GC ，否则将进行Full GC。</p>
<h2 id="5-逃逸分析和栈上分配"><a href="#5-逃逸分析和栈上分配" class="headerlink" title="5.逃逸分析和栈上分配"></a>5.逃逸分析和栈上分配</h2><p><a target="_blank" rel="noopener" href="https://blog.csdn.net/blueheart20/article/details/52050545">https://blog.csdn.net/blueheart20/article/details/52050545</a></p>
<p>讲的比较好</p>
<p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/fuguoliang/p/9753061.html">https://www.cnblogs.com/fuguoliang/p/9753061.html</a></p>
<p>发生逃逸的不要用栈上分配。</p>
<h4 id="如何查看逃逸分析的筛选结果"><a href="#如何查看逃逸分析的筛选结果" class="headerlink" title="如何查看逃逸分析的筛选结果"></a>如何查看逃逸分析的筛选结果</h4><p>参考:链接：<a target="_blank" rel="noopener" href="https://www.jianshu.com/p/f1e5e03ed2f8">https://www.jianshu.com/p/f1e5e03ed2f8</a></p>
<p>可以通过配置 -XX:+PrintEscapeAnalysis 开启打印逃逸分析筛选结果</p>
<p>栈上分配需要有一定的前提</p>
<ul>
<li>开启逃逸分析 (-XX:+DoEscapeAnalysis)</li>
</ul>
<p>逃逸分析的作用就是分析对象的作用域是否会逃逸出方法之外，再server虚拟机模式下才可以开启（jdk1.6默认开启）</p>
<ul>
<li>开启标量替换 (-XX:+EliminateAllocations)</li>
</ul>
<p>标量替换的作用是允许将对象根据属性打散后分配再栈上，默认该配置为开启</p>
<h2 id="6-TLAB-线程本地分配缓存"><a href="#6-TLAB-线程本地分配缓存" class="headerlink" title="6.TLAB 线程本地分配缓存"></a>6.TLAB 线程本地分配缓存</h2><p>全称叫做：Thread Local Allocation Buffer 即线程本地分配缓存</p>
<p>那么能不能构造一种线程私有的堆空间，哪怕这块堆空间特别小，但是只要有，就可以每个线程在分配对象到堆空间时，先分配到自己所属的那一块堆空间中，<strong>避免同步</strong>带来的效率问题，从而<strong>提高分配效率</strong>。</p>
<p>参考链接：<a target="_blank" rel="noopener" href="https://www.jianshu.com/p/f1e5e03ed2f8">https://www.jianshu.com/p/f1e5e03ed2f8</a></p>
<hr>
<p>完</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://hufanglei.github.io/2019/12/31/jvm(9)%20--%20cms%E6%94%B6%E9%9B%86%E5%99%A8%E3%80%81G1%E6%94%B6%E9%9B%86%E5%99%A8/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="胡方雷">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="个人博客">
      <meta itemprop="description" content="直到这一刻微笑着说话为止，我至少留下了一公升眼泪">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | 个人博客">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2019/12/31/jvm(9)%20--%20cms%E6%94%B6%E9%9B%86%E5%99%A8%E3%80%81G1%E6%94%B6%E9%9B%86%E5%99%A8/" class="post-title-link" itemprop="url">jvm(9) -- cms收集器、G1收集器</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2019-12-31 10:18:51" itemprop="dateCreated datePublished" datetime="2019-12-31T10:18:51+08:00">2019-12-31</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2025-01-24 11:37:59" itemprop="dateModified" datetime="2025-01-24T11:37:59+08:00">2025-01-24</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/jvm/" itemprop="url" rel="index"><span itemprop="name">jvm</span></a>
        </span>
    </span>

  
    <span class="post-meta-break"></span>
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>6.9k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>6 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <span id="more"></span>

<p>@[toc]</p>
<h1 id="1-Cms收集器"><a href="#1-Cms收集器" class="headerlink" title="1.Cms收集器"></a>1.Cms收集器</h1><p><img src="https://raw.githubusercontent.com/hufanglei/img-csdn/main/img/2025-1-13/73f53d84d325cbc50a511a0fc76adfda_1737626776516.png" alt="在这里插入图片描述"></p>
<p>摘自文章:<a target="_blank" rel="noopener" href="https://www.jianshu.com/p/29460c44c664">https://www.jianshu.com/p/29460c44c664</a></p>
<p>CMS(Concurrent Mark Swep)收集器是一个比较重要的回收器，现在应用非常广泛，我们重点来看一下，CMS一种获取最短回收停顿时间为目标的收集器，这使得它很适合用于和用户交互的业务。从名字(Mark Swep)就可以看出，CMS收集器是基于标记清除算法实现的。它的收集过程分为四个步骤：</p>
<p>1.初始标记(initial mark)</p>
<p>2.并发标记(concurrent mark)</p>
<p>3.重新标记(remark)</p>
<p>4.并发清除(concurrent sweep)</p>
<p>注意初始标记和重新标记还是会stop the world，但是在耗费时间更长的并发标记和并发清除两个阶段都可以和用户进程同时工作。</p>
<p>不过由于CMS收集器是基于标记清除算法实现的，会导致有大量的空间碎片产生，在为大对象分配内存的时候，往往会出现老年代还有很大的空间剩余，但是无法找到足够大的连续空间来分配当前对象，不得不提前开启一次Full GC。为了解决这个问题，CMS收集器默认提供了一个-<code>XX:+UseCMSCompactAtFullCollection</code>收集开关参数（默认就是开启的)，用于在CMS收集器进行FullGC完开启内存碎片的合并整理过程，内存整理的过程是无法并发的，这样内存碎片问题倒是没有了，不过停顿时间不得不变长。虚拟机设计者还提供了另外一个参数-<code>XX:CMSFullGCsBeforeCompaction</code>参数用于设置执行多少次不压缩的FULL GC后跟着来一次带压缩的（默认值为0，表示每次进入Full GC时都进行碎片整理）。</p>
<p>不幸的是，它作为老年代的收集器，却无法与jdk1.4中已经存在的新生代收集器Parallel Scavenge配合工作，所以在jdk1.5中使用cms来收集老年代的时候，新生代只能选择ParNew或Serial收集器中的一个。ParNew收集器是使用<code>-XX:+UseConcMarkSweepGC</code>选项启用CMS收集器之后的默认新生代收集器，也可以使用<code>-XX:+UseParNewGC</code>选项来强制指定它。</p>
<p>摘自文章:<a target="_blank" rel="noopener" href="https://www.breakyizhan.com/javamianshiti/2856.html">https://www.breakyizhan.com/javamianshiti/2856.html</a></p>
<p>并发标记清理（Concurrent Mark Sweep，CMS）收集器也称为并发低停顿收集器（Concurrent Low Pause Collector）或低延迟（low-latency）垃圾收集器；</p>
<p>在前面ParNew收集器曾简单介绍过其特点；</p>
<h2 id="①、特点"><a href="#①、特点" class="headerlink" title="①、特点"></a>①、特点</h2><p>针对老年代；</p>
<p>基于”标记-清除”算法(不进行压缩操作，产生内存碎片)；</p>
<p>以获取最短回收停顿时间为目标；</p>
<p>并发收集、低停顿；</p>
<p>需要更多的内存（看后面的缺点）；</p>
<p>是HotSpot在JDK1.5推出的第一款真正意义上的并发（Concurrent）收集器；</p>
<p>第一次实现了让垃圾收集线程与用户线程（基本上）同时工作；</p>
<h2 id="②、应用场景"><a href="#②、应用场景" class="headerlink" title="②、应用场景"></a>②、应用场景</h2><p>与用户交互较多的场景；</p>
<p>希望系统停顿时间最短，注重服务的响应速度；</p>
<p>以给用户带来较好的体验；</p>
<p>如常见WEB、B&#x2F;S系统的服务器上的应用；</p>
<h2 id="③、设置参数"><a href="#③、设置参数" class="headerlink" title="③、设置参数"></a>③、设置参数</h2><p>“-XX:+UseConcMarkSweepGC”：指定使用CMS收集器；</p>
<h2 id="④、CMS收集器运作过程"><a href="#④、CMS收集器运作过程" class="headerlink" title="④、CMS收集器运作过程"></a>④、CMS收集器运作过程</h2><p>比前面几种收集器更复杂，可以分为4个步骤:</p>
<p>（A）、初始标记（CMS initial mark）</p>
<p>仅标记一下GC Roots能直接关联到的对象；</p>
<p>速度很快；</p>
<p>但需要”Stop The World”；</p>
<p>（B）、并发标记（CMS concurrent mark）</p>
<p>进行GC Roots Tracing的过程；</p>
<p>刚才产生的集合中标记出存活对象；</p>
<p>应用程序也在运行；</p>
<p>并不能保证可以标记出所有的存活对象；</p>
<p>（C）、重新标记（CMS remark）</p>
<p>为了修正并发标记期间因用户程序继续运作而导致标记变动的那一部分对象的标记记录；</p>
<p>需要”Stop The World”，且停顿时间比初始标记稍长，但远比并发标记短；</p>
<p>采用多线程并行执行来提升效率；</p>
<p>（D）、并发清除（CMS concurrent sweep）</p>
<p>回收所有的垃圾对象；</p>
<p>整个过程中耗时最长的并发标记和并发清除都可以与用户线程一起工作；</p>
<p>所以总体上说，CMS收集器的内存回收过程与用户线程一起并发执行；</p>
<p>CMS收集器运行示意图如下：</p>
<p><a target="_blank" rel="noopener" href="https://raw.githubusercontent.com/hufanglei/img-csdn/main/img/2025-1-13/baff2b7ac2160fe31077db078160cf7b_1737626776516.png"><img src="https://i-blog.csdnimg.cn/blog_migrate/8bd7c3bfaab536389385f8ee2fd060d9.png" alt="img"></a></p>
<h2 id="⑤、CMS收集器3个明显的缺点"><a href="#⑤、CMS收集器3个明显的缺点" class="headerlink" title="⑤、CMS收集器3个明显的缺点"></a>⑤、CMS收集器3个明显的缺点</h2><h3 id="（A）对CPU资源非常敏感"><a href="#（A）对CPU资源非常敏感" class="headerlink" title="（A）对CPU资源非常敏感"></a>（A）对CPU资源非常敏感</h3><p>并发收集虽然不会暂停用户线程，但因为占用一部分CPU资源，还是会导致应用程序变慢，总吞吐量降低。</p>
<p>CMS的默认收集线程数量是&#x3D;(CPU数量+3)&#x2F;4；</p>
<p>当CPU数量多于4个，收集线程占用的CPU资源多于25%，对用户程序影响可能较大；不足4个时，影响更大，可能无法接受。</p>
<p>增量式并发收集器：</p>
<p>针对这种情况，曾出现了”增量式并发收集器”（Incremental Concurrent Mark Sweep&#x2F;i-CMS）；</p>
<p>类似使用抢占式来模拟多任务机制的思想，让收集线程和用户线程交替运行，减少收集线程运行时间；</p>
<p>但效果并不理想，JDK1.6后就官方不再提倡用户使用。</p>
<p>更多请参考：</p>
<p>官方的《垃圾收集调优指南》8.8节 Incremental Mode：<a target="_blank" rel="noopener" href="http://docs.oracle.com/javase/8/docs/technotes/guides/vm/gctuning/cms.html#CJAGIIEJ">http://docs.oracle.com/javase/8/docs/technotes/guides/vm/gctuning/cms.html#CJAGIIEJ</a></p>
<p>《内存管理白皮书》 4.6.3节可以看到一些描述；</p>
<h3 id="（B）无法处理浮动垃圾-可能出现”Concurrent-Mode-Failure”失败"><a href="#（B）无法处理浮动垃圾-可能出现”Concurrent-Mode-Failure”失败" class="headerlink" title="（B）无法处理浮动垃圾,可能出现”Concurrent Mode Failure”失败"></a>（B）无法处理浮动垃圾,可能出现”Concurrent Mode Failure”失败</h3><ul>
<li>（1）、浮动垃圾（Floating Garbage）</li>
</ul>
<p>在并发清除时，用户线程新产生的垃圾，称为浮动垃圾；</p>
<p>这使得并发清除时需要预留一定的内存空间，不能像其他收集器在老年代几乎填满再进行收集；</p>
<p>也要可以认为CMS所需要的空间比其他垃圾收集器大；</p>
<p>“-XX:CMSInitiatingOccupancyFraction”：设置CMS预留内存空间；</p>
<p>JDK1.5默认值为68%；</p>
<p>JDK1.6变为大约92%；</p>
<ul>
<li>（2）、”Concurrent Mode Failure”失败</li>
</ul>
<p>如果CMS预留内存空间无法满足程序需要，就会出现一次”Concurrent Mode Failure”失败；</p>
<p>这时JVM启用后备预案：临时启用Serail Old收集器，而导致另一次Full GC的产生；</p>
<p>这样的代价是很大的，所以CMSInitiatingOccupancyFraction不能设置得太大。</p>
<h3 id="（C）产生大量内存碎片"><a href="#（C）产生大量内存碎片" class="headerlink" title="（C）产生大量内存碎片"></a>（C）产生大量内存碎片</h3><p>由于CMS基于”标记-清除”算法，清除后不进行压缩操作；</p>
<p>前面《Java虚拟机垃圾回收(二) 垃圾回收算法》”标记-清除”算法介绍时曾说过：</p>
<p>产生大量不连续的内存碎片会导致分配大内存对象时，无法找到足够的连续内存，从而需要提前触发另一次Full GC动作。</p>
<p>解决方法：</p>
<p>（1）、”-XX:+UseCMSCompactAtFullCollection”</p>
<p>使得CMS出现上面这种情况时不进行Full GC，而开启内存碎片的合并整理过程；</p>
<p>但合并整理过程无法并发，停顿时间会变长；</p>
<p>默认开启（但不会进行，结合下面的CMSFullGCsBeforeCompaction）；</p>
<p>（2）、”-XX:+CMSFullGCsBeforeCompaction”</p>
<p>设置执行多少次不压缩的Full GC后，来一次压缩整理；</p>
<p>为减少合并整理过程的停顿时间；</p>
<p>默认为0，也就是说每次都执行Full GC，不会进行压缩整理；</p>
<p>由于空间不再连续，CMS需要使用可用”空闲列表”内存分配方式，这比简单实用”碰撞指针”分配内存消耗大；</p>
<p>更多关于内存分配方式请参考：《Java对象在Java虚拟机中的创建过程》</p>
<p>总体来看，与Parallel Old垃圾收集器相比，CMS减少了执行老年代垃圾收集时应用暂停的时间；</p>
<p>但却增加了新生代垃圾收集时应用暂停的时间、降低了吞吐量而且需要占用更大的堆空间；</p>
<p>更多CMS收集器信息请参考：</p>
<p>《垃圾收集调优指南》 8节 Concurrent Mark Sweep (CMS) Collector：<a target="_blank" rel="noopener" href="http://docs.oracle.com/javase/8/docs/technotes/guides/vm/gctuning/cms.html#concurrent_mark_sweep_cms_collector">http://docs.oracle.com/javase/8/docs/technotes/guides/vm/gctuning/cms.html#concurrent_mark_sweep_cms_collector</a></p>
<p>《内存管理白皮书》 4.6节 Concurrent Mark-Sweep (CMS) Collector：<a target="_blank" rel="noopener" href="http://www.oracle.com/technetwork/java/javase/tech/memorymanagement-whitepaper-1-150020.pdf">http://www.oracle.com/technetwork/java/javase/tech/memorymanagement-whitepaper-1-150020.pdf</a></p>
<h1 id="2-G1收集器"><a href="#2-G1收集器" class="headerlink" title="2.G1收集器"></a>2.G1收集器</h1><p><img src="https://raw.githubusercontent.com/hufanglei/img-csdn/main/img/2025-1-13/17ec6da7064f0aef4d123c1e08b1e933_1737626776516.png" alt="在这里插入图片描述"></p>
<p>摘自:<a target="_blank" rel="noopener" href="https://www.jianshu.com/p/29460c44c664">https://www.jianshu.com/p/29460c44c664</a></p>
<p>G1收集器是一款面向服务端应用的垃圾收集器。HotSpot团队赋予它的使命是在未来替换掉JDK1.5中发布的CMS收集器。与其他GC收集器相比，G1具备如下特点：</p>
<p>并行与并发：G1能更充分的利用CPU，多核环境下的硬件优势来缩短stop the world的停顿时间。</p>
<p>分代收集：和其他收集器一样，分代的概念在G1中依然存在，不过G1不需要其他的垃圾回收器的配合就可以独自管理整个GC堆。</p>
<p>空间整合：G1收集器有利于程序长时间运行，分配大对象时不会无法得到连续的空间而提前触发一次GC。</p>
<p>可预测的非停顿：这是G1相对于CMS的另一大优势，降低停顿时间是G1和CMS共同的关注点，能让使用者明确指定在一个长度为M毫秒的时间片段内，消耗在垃圾收集上的时间不得超过N毫秒。</p>
<p>在使用G1收集器时，Java堆的内存布局和其他收集器有很大的差别，它将这个Java堆分为多个大小相等的独立区域，虽然还保留新生代和老年代的概念，但是新生代和老年代不再是物理隔离的了，它们都是一部分Region（不需要连续）的集合。</p>
<p>摘自:&lt;<a target="_blank" rel="noopener" href="https://www.jianshu.com/p/29460c44c664">https://www.jianshu.com/p/29460c44c664</a></p>
<p>G1（Garbage-First）是JDK7-u4才推出商用的收集器；</p>
<h2 id="①、特点-1"><a href="#①、特点-1" class="headerlink" title="①、特点"></a>①、特点</h2><h3 id="（A）、并行与并发"><a href="#（A）、并行与并发" class="headerlink" title="（A）、并行与并发"></a>（A）、并行与并发</h3><p>能充分利用多CPU、多核环境下的硬件优势；</p>
<p>可以并行来缩短”Stop The World”停顿时间；</p>
<p>也可以并发让垃圾收集与用户程序同时进行；</p>
<h3 id="（B）、分代收集，收集范围包括新生代和老年代"><a href="#（B）、分代收集，收集范围包括新生代和老年代" class="headerlink" title="（B）、分代收集，收集范围包括新生代和老年代"></a>（B）、分代收集，收集范围包括新生代和老年代</h3><p>能独立管理整个GC堆（新生代和老年代），而不需要与其他收集器搭配；</p>
<p>能够采用不同方式处理不同时期的对象；</p>
<p>虽然保留分代概念，但Java堆的内存布局有很大差别；</p>
<p>将整个堆划分为多个大小相等的独立区域（Region）；</p>
<p>新生代和老年代不再是物理隔离，它们都是一部分Region（不需要连续）的集合；</p>
<p>更多G1内存布局信息请参考：</p>
<p>《垃圾收集调优指南》 9节：<a target="_blank" rel="noopener" href="http://docs.oracle.com/javase/8/docs/technotes/guides/vm/gctuning/g1_gc.html#garbage_first_garbage_collection">http://docs.oracle.com/javase/8/docs/technotes/guides/vm/gctuning/g1_gc.html#garbage_first_garbage_collection</a></p>
<h3 id="（C）、结合多种垃圾收集算法，空间整合，不产生碎片"><a href="#（C）、结合多种垃圾收集算法，空间整合，不产生碎片" class="headerlink" title="（C）、结合多种垃圾收集算法，空间整合，不产生碎片"></a>（C）、结合多种垃圾收集算法，空间整合，不产生碎片</h3><p>从整体看，是基于标记-整理算法；</p>
<p>从局部（两个Region间）看，是基于复制算法；</p>
<p>这是一种类似火车算法的实现；</p>
<p>都不会产生内存碎片，有利于长时间运行；</p>
<h3 id="（D）、可预测的停顿：低停顿的同时实现高吞吐量"><a href="#（D）、可预测的停顿：低停顿的同时实现高吞吐量" class="headerlink" title="（D）、可预测的停顿：低停顿的同时实现高吞吐量"></a>（D）、可预测的停顿：低停顿的同时实现高吞吐量</h3><p>G1除了追求低停顿处，还能建立可预测的停顿时间模型；</p>
<p>可以明确指定M毫秒时间片内，垃圾收集消耗的时间不超过N毫秒；</p>
<h2 id="②、应用场景-1"><a href="#②、应用场景-1" class="headerlink" title="②、应用场景"></a>②、应用场景</h2><p>面向服务端应用，针对具有大内存、多处理器的机器；</p>
<p>最主要的应用是为需要低GC延迟，并具有大堆的应用程序提供解决方案；</p>
<p>如：在堆大小约6GB或更大时，可预测的暂停时间可以低于0.5秒；</p>
<p>用来替换掉JDK1.5中的CMS收集器；</p>
<p>在下面的情况时，使用G1可能比CMS好：</p>
<p>（1）、超过50％的Java堆被活动数据占用；</p>
<p>（2）、对象分配频率或年代提升频率变化很大；</p>
<p>（3）、GC停顿时间过长（长于0.5至1秒）。</p>
<p>是否一定采用G1呢？也未必：</p>
<p>如果现在采用的收集器没有出现问题，不用急着去选择G1；</p>
<p>如果应用程序追求低停顿，可以尝试选择G1；</p>
<p>是否代替CMS需要实际场景测试才知道。</p>
<h2 id="③、设置参数-1"><a href="#③、设置参数-1" class="headerlink" title="③、设置参数"></a>③、设置参数</h2><p>“-XX:+UseG1GC”：指定使用G1收集器；</p>
<p>“-XX:InitiatingHeapOccupancyPercent”：当整个Java堆的占用率达到参数值时，开始并发标记阶段；默认为45；</p>
<p>“-XX:MaxGCPauseMillis”：为G1设置暂停时间目标，默认值为200毫秒；</p>
<p>“-XX:G1HeapRegionSize”：设置每个Region大小，范围1MB到32MB；目标是在最小Java堆时可以拥有约2048个Region；</p>
<p>更多关于G1参数设置请参考：</p>
<p>《垃圾收集调优指南》 10.5节：<a target="_blank" rel="noopener" href="http://docs.oracle.com/javase/8/docs/technotes/guides/vm/gctuning/g1_gc_tuning.html#important_defaults">http://docs.oracle.com/javase/8/docs/technotes/guides/vm/gctuning/g1_gc_tuning.html#important_defaults</a></p>
<h2 id="④、为什么G1收集器可以实现可预测的停顿"><a href="#④、为什么G1收集器可以实现可预测的停顿" class="headerlink" title="④、为什么G1收集器可以实现可预测的停顿"></a>④、为什么G1收集器可以实现可预测的停顿</h2><p>G1可以建立可预测的停顿时间模型，是因为：</p>
<p>可以有计划地避免在Java堆的进行全区域的垃圾收集；</p>
<p>G1跟踪各个Region获得其收集价值大小，在后台维护一个优先列表；</p>
<p>每次根据允许的收集时间，优先回收价值最大的Region（名称Garbage-First的由来）；</p>
<p>这就保证了在有限的时间内可以获取尽可能高的收集效率；</p>
<h2 id="⑤、一个对象被不同区域引用的问题"><a href="#⑤、一个对象被不同区域引用的问题" class="headerlink" title="⑤、一个对象被不同区域引用的问题"></a>⑤、一个对象被不同区域引用的问题</h2><p>一个Region不可能是孤立的，一个Region中的对象可能被其他任意Region中对象引用，判断对象存活时，是否需要扫描整个Java堆才能保证准确？</p>
<p>在其他的分代收集器，也存在这样的问题（而G1更突出）：</p>
<p>回收新生代也不得不同时扫描老年代？</p>
<p>这样的话会降低Minor GC的效率；</p>
<p>解决方法：</p>
<p>无论G1还是其他分代收集器，JVM都是使用Remembered Set来避免全局扫描：</p>
<p>每个Region都有一个对应的Remembered Set；</p>
<p>每次Reference类型数据写操作时，都会产生一个Write Barrier暂时中断操作；</p>
<p>然后检查将要写入的引用指向的对象是否和该Reference类型数据在不同的Region（其他收集器：检查老年代对象是否引用了新生代对象）；</p>
<p>如果不同，通过CardTable把相关引用信息记录到引用指向对象的所在Region对应的Remembered Set中；</p>
<p>当进行垃圾收集时，在GC根节点的枚举范围加入Remembered Set；</p>
<p>就可以保证不进行全局扫描，也不会有遗漏。</p>
<h2 id="⑥、G1收集器运作过程"><a href="#⑥、G1收集器运作过程" class="headerlink" title="⑥、G1收集器运作过程"></a>⑥、G1收集器运作过程</h2><p>不计算维护Remembered Set的操作，可以分为4个步骤（与CMS较为相似）。</p>
<h3 id="（A）、初始标记（Initial-Marking）"><a href="#（A）、初始标记（Initial-Marking）" class="headerlink" title="（A）、初始标记（Initial Marking）"></a>（A）、初始标记（Initial Marking）</h3><p>仅标记一下GC Roots能直接关联到的对象；</p>
<p>且修改TAMS（Next Top at Mark Start）,让下一阶段并发运行时，用户程序能在正确可用的Region中创建新对象；</p>
<p>需要”Stop The World”，但速度很快；</p>
<h3 id="（B）、并发标记（Concurrent-Marking）"><a href="#（B）、并发标记（Concurrent-Marking）" class="headerlink" title="（B）、并发标记（Concurrent Marking）"></a>（B）、并发标记（Concurrent Marking）</h3><p>进行GC Roots Tracing的过程；</p>
<p>刚才产生的集合中标记出存活对象；</p>
<p>耗时较长，但应用程序也在运行；</p>
<p>并不能保证可以标记出所有的存活对象；</p>
<h3 id="（C）、最终标记（Final-Marking）"><a href="#（C）、最终标记（Final-Marking）" class="headerlink" title="（C）、最终标记（Final Marking）"></a>（C）、最终标记（Final Marking）</h3><p>为了修正并发标记期间因用户程序继续运作而导致标记变动的那一部分对象的标记记录；</p>
<p>上一阶段对象的变化记录在线程的Remembered Set Log；</p>
<p>这里把Remembered Set Log合并到Remembered Set中；</p>
<p>需要”Stop The World”，且停顿时间比初始标记稍长，但远比并发标记短；</p>
<p>采用多线程并行执行来提升效率；</p>
<h3 id="（D）、筛选回收（Live-Data-Counting-and-Evacuation）"><a href="#（D）、筛选回收（Live-Data-Counting-and-Evacuation）" class="headerlink" title="（D）、筛选回收（Live Data Counting and Evacuation）"></a>（D）、筛选回收（Live Data Counting and Evacuation）</h3><p>首先排序各个Region的回收价值和成本；</p>
<p>然后根据用户期望的GC停顿时间来制定回收计划；</p>
<p>最后按计划回收一些价值高的Region中垃圾对象；</p>
<p>回收时采用”复制”算法，从一个或多个Region复制存活对象到堆上的另一个空的Region，并且在此过程中压缩和释放内存；</p>
<p>可以并发进行，降低停顿时间，并增加吞吐量；</p>
<p>G1收集器运行示意图如下：</p>
<p><img src="https://raw.githubusercontent.com/hufanglei/img-csdn/main/img/2025-1-13/abc64dab2de6d6d7d207636562da5199_1737626776516.png" alt="在这里插入图片描述"><br>更多G1收集器信息请参考：</p>
<p>《垃圾收集调优指南》 9节 Garbage-First Garbage Collector：<a target="_blank" rel="noopener" href="http://docs.oracle.com/javase/8/docs/technotes/guides/vm/gctuning/g1_gc.html#garbage_first_garbage_collection">http://docs.oracle.com/javase/8/docs/technotes/guides/vm/gctuning/g1_gc.html#garbage_first_garbage_collection</a></p>
<p>《垃圾收集调优指南》 10节 Garbage-First Garbage Collector Tuning：<a target="_blank" rel="noopener" href="http://docs.oracle.com/javase/8/docs/technotes/guides/vm/gctuning/g1_gc_tuning.html#g1_gc_tuning">http://docs.oracle.com/javase/8/docs/technotes/guides/vm/gctuning/g1_gc_tuning.html#g1_gc_tuning</a></p>
<hr>
<p>完</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://hufanglei.github.io/2019/12/30/%E8%BF%9B%E9%98%B6%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F(2)%20--%20%E5%A4%96%E8%A7%82%E6%A8%A1%E5%BC%8F/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="胡方雷">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="个人博客">
      <meta itemprop="description" content="直到这一刻微笑着说话为止，我至少留下了一公升眼泪">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | 个人博客">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2019/12/30/%E8%BF%9B%E9%98%B6%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F(2)%20--%20%E5%A4%96%E8%A7%82%E6%A8%A1%E5%BC%8F/" class="post-title-link" itemprop="url">进阶设计模式(2) -- 外观模式</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2019-12-30 23:15:12" itemprop="dateCreated datePublished" datetime="2019-12-30T23:15:12+08:00">2019-12-30</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2025-01-24 11:37:59" itemprop="dateModified" datetime="2025-01-24T11:37:59+08:00">2025-01-24</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/" itemprop="url" rel="index"><span itemprop="name">设计模式</span></a>
        </span>
    </span>

  
    <span class="post-meta-break"></span>
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>39</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>1 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <span id="more"></span>

<p>@[toc]</p>
<p><img src="https://i-blog.csdnimg.cn/blog_migrate/abc64dab2de6d6d7d207636562da5199.png" alt="在这里插入图片描述"></p>
<h1 id="1-初识外观模式"><a href="#1-初识外观模式" class="headerlink" title="1.初识外观模式"></a>1.初识外观模式</h1><p><img src="https://i-blog.csdnimg.cn/blog_migrate/ce39a53e07682408a6091f2282d9eeeb.png" alt="在这里插入图片描述"><img src="https://i-blog.csdnimg.cn/blog_migrate/40009b14a9c584821a4b74ee995293f9.png" alt="在这里插入图片描述"><img src="https://raw.githubusercontent.com/hufanglei/img-csdn/main/img/2025-1-13/656c39b88da8ac9d6d23e88a506a9a65_1737626785584.png" alt="在这里插入图片描述"></p>
<h1 id="2-体会外观模式"><a href="#2-体会外观模式" class="headerlink" title="2.体会外观模式"></a>2.体会外观模式</h1><p><img src="https://i-blog.csdnimg.cn/blog_migrate/e2742a569ca365c2795abe5847db2134.png" alt="在这里插入图片描述"><img src="https://raw.githubusercontent.com/hufanglei/img-csdn/main/img/2025-1-13/c5d5a9a3077a617830487d6cd4c981e0_1737626785584.png" alt="在这里插入图片描述"><br><img src="https://raw.githubusercontent.com/hufanglei/img-csdn/main/img/2025-1-13/87663f0d7eac9e303681ae981f04141a_1737626785584.png" alt="在这里插入图片描述"></p>
<h1 id="3-理解外观模式"><a href="#3-理解外观模式" class="headerlink" title="3.理解外观模式"></a>3.理解外观模式</h1><p><img src="https://raw.githubusercontent.com/hufanglei/img-csdn/main/img/2025-1-13/ca69bd490cb4fc4f5abcc74604771853_1737626785584.png" alt="在这里插入图片描述"><br><img src="https://raw.githubusercontent.com/hufanglei/img-csdn/main/img/2025-1-13/0706f5662ec5ce5a123788b6fcfe318e_1737626785584.png" alt="在这里插入图片描述"><br><img src="https://raw.githubusercontent.com/hufanglei/img-csdn/main/img/2025-1-13/2018beb83d4b74aa0f182dee5b84bafd_1737626806629.png" alt="在这里插入图片描述"><br><img src="https://raw.githubusercontent.com/hufanglei/img-csdn/main/img/2025-1-13/719aaca56c10517a4d5c5c62ccc37f3e_1737626806629.png" alt="在这里插入图片描述"></p>
<h1 id="4-思考外观模式"><a href="#4-思考外观模式" class="headerlink" title="4.思考外观模式"></a>4.思考外观模式</h1><p><img src="https://raw.githubusercontent.com/hufanglei/img-csdn/main/img/2025-1-13/f4afaff8bcc2c1cf24158290de08b1a9_1737626806629.png" alt="在这里插入图片描述"></p>
<hr>
<p>完</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://hufanglei.github.io/2019/12/30/jvm(8)%20--%20Serial%E6%94%B6%E9%9B%86%E5%99%A8%E3%80%81ParNew%E6%94%B6%E9%9B%86%E5%99%A8%E3%80%81Parallel%20Scavenge%E6%94%B6%E9%9B%86%E5%99%A8/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="胡方雷">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="个人博客">
      <meta itemprop="description" content="直到这一刻微笑着说话为止，我至少留下了一公升眼泪">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | 个人博客">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2019/12/30/jvm(8)%20--%20Serial%E6%94%B6%E9%9B%86%E5%99%A8%E3%80%81ParNew%E6%94%B6%E9%9B%86%E5%99%A8%E3%80%81Parallel%20Scavenge%E6%94%B6%E9%9B%86%E5%99%A8/" class="post-title-link" itemprop="url">jvm(8) -- Serial收集器、ParNew收集器、Parallel Scavenge收集器</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2019-12-30 14:53:08" itemprop="dateCreated datePublished" datetime="2019-12-30T14:53:08+08:00">2019-12-30</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2025-01-24 11:37:59" itemprop="dateModified" datetime="2025-01-24T11:37:59+08:00">2025-01-24</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/jvm/" itemprop="url" rel="index"><span itemprop="name">jvm</span></a>
        </span>
    </span>

  
    <span class="post-meta-break"></span>
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>5k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>5 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <span id="more"></span>

<p>@[toc]</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">查询JDK默认GC： java -XX:+PrintCommandLineFlags -version</span><br></pre></td></tr></table></figure>
<p><img src="https://raw.githubusercontent.com/hufanglei/img-csdn/main/img/2025-1-13/8c027555296ec57beecf7ed7770e7180_1737626806629.png" alt="在这里插入图片描述"><br>摘自:<br><a target="_blank" rel="noopener" href="https://www.jianshu.com/p/29460c44c664">https://www.jianshu.com/p/29460c44c664</a></p>
<h1 id="1-Serial收集器"><a href="#1-Serial收集器" class="headerlink" title="1.Serial收集器"></a>1.Serial收集器</h1><p>推荐文章:<a target="_blank" rel="noopener" href="https://www.breakyizhan.com/javamianshiti/2850.html">https://www.breakyizhan.com/javamianshiti/2850.html</a></p>
<p>Serial，是单线程执行垃圾回收的。当需要执行垃圾回收时，程序会暂停一切手上的工作，然后单线程执行垃圾回收。</p>
<p>因为新生代的特点是对象存活率低，所以收集算法用的是复制算法，把新生代存活对象复制到老年代，复制的内容不多，性能较好。</p>
<p>Serial（串行）垃圾收集器是最基本、发展历史最悠久的收集器；</p>
<p>JDK1.3.1前是HotSpot新生代收集的唯一选择；</p>
<h2 id="①特点"><a href="#①特点" class="headerlink" title="①特点"></a>①特点</h2><p>针对新生代；</p>
<p>采用复制算法；</p>
<p>单线程收集；</p>
<p>进行垃圾收集时，必须暂停所有工作线程，直到完成；</p>
<p>即会”Stop The World”；</p>
<p>Serial&#x2F;Serial Old组合收集器运行示意图如下：<br><a target="_blank" rel="noopener" href="https://cdn.breakyizhan.com/wp-content/uploads/2018/03/1522482280-7230-.png"><img src="https://i-blog.csdnimg.cn/blog_migrate/da9821b6854811174ceb49c7c6d05d42.png" alt="img"></a></p>
<h2 id="②、应用场景"><a href="#②、应用场景" class="headerlink" title="②、应用场景"></a>②、应用场景</h2><p>依然是HotSpot在Client模式下默认的新生代收集器；</p>
<p>也有优于其他收集器的地方：<br>简单高效（与其他收集器的单线程相比）；</p>
<p>对于限定单个CPU的环境来说，Serial收集器没有线程交互（切换）开销，可以获得最高的单线程收集效率；</p>
<p>在用户的桌面应用场景中，可用内存一般不大（几十M至一两百M），可以在较短时间内完成垃圾收集（几十MS至一百多MS）,只要不频繁发生，这是可以接受的</p>
<h2 id="③、设置参数"><a href="#③、设置参数" class="headerlink" title="③、设置参数"></a>③、设置参数</h2><p>“-XX:+UseSerialGC”：添加该参数来显式的使用串行垃圾收集器；</p>
<h2 id="④Stop-TheWorld说明"><a href="#④Stop-TheWorld说明" class="headerlink" title="④Stop TheWorld说明"></a>④Stop TheWorld说明</h2><p>JVM在后台自动发起和自动完成的，在用户不可见的情况下，把用户正常的工作线程全部停掉，即GC停顿；</p>
<p>会带给用户不良的体验；<br>从JDK1.3到现在，从Serial收集器-》Parallel收集器-》CMS-》G1，用户线程停顿时间不断缩短，但仍然无法完全消除；</p>
<p>单线程地好处就是减少上下文切换，减少系统资源的开销。但这种方式的缺点也很明显，在GC的过程中，会暂停程序的执行。若GC不是频繁发生，这或许是一个不错的选择，否则将会影响程序的执行性能。 对于新生代来说，区域比较小，停顿时间短，所以比较使用。</p>
<h1 id="2-ParNew收集器"><a href="#2-ParNew收集器" class="headerlink" title="2.ParNew收集器"></a>2.ParNew收集器</h1><p>引文章链接：<a target="_blank" rel="noopener" href="https://www.jianshu.com/p/29460c44c664">https://www.jianshu.com/p/29460c44c664</a></p>
<p>ParNew收集器是Serial收集器新生代的多线程实现，注意在进行垃圾回收的时候依然会stop the world，只是相比较Serial收集器而言它会运行多条进程进行垃圾回收。</p>
<p>ParNew收集器在单CPU的环境中绝对不会有比Serial收集器更好的效果，甚至由于存在线程交互的开销，该收集器在通过超线程技术实现的两个CPU的环境中都不能百分之百的保证能超越Serial收集器。当然，随着可以使用的CPU的数量增加，它对于GC时系统资源的利用还是很有好处的。它默认开启的收集线程数与CPU的数量相同，在CPU非常多（譬如32个，现在CPU动辄4核加超线程，服务器超过32个逻辑CPU的情况越来越多了）的环境下，可以使用<code>-XX:ParallelGCThreads</code>参数来限制垃圾收集的线程数。</p>
<p><code>-UseParNewGC</code>: 打开此开关后，使用ParNew + Serial Old的收集器组合进行内存回收，这样新生代使用并行收集器，老年代使用串行收集器。</p>
<p>引文章链接：<a target="_blank" rel="noopener" href="https://www.breakyizhan.com/javamianshiti/2852.html">https://www.breakyizhan.com/javamianshiti/2852.html</a></p>
<p>ParNew垃圾收集器是<strong>Serial收集器的多线程版本</strong>。</p>
<h2 id="①特点-1"><a href="#①特点-1" class="headerlink" title="①特点"></a>①特点</h2><p>除了多线程外，其余的行为、特点和Serial收集器一样；</p>
<p>如<a target="_blank" rel="noopener" href="https://www.breakyizhan.com/javamianshiti/2850.html">Serial收集器</a>可用控制参数、收集算法、Stop The World、内存分配规则、回收策略等；</p>
<p>两个收集器共用了不少代码；</p>
<p>​      <strong>ParNew&#x2F;Serial Old组合收集器运行示意图如下：</strong></p>
<p><a target="_blank" rel="noopener" href="https://raw.githubusercontent.com/hufanglei/img-csdn/main/img/2025-1-13/46ad33e0c5a7fc52c4293f978f001fe0_1737626826179.png"><img src="https://i-blog.csdnimg.cn/blog_migrate/1607e550ac44aa1cecc9dc98bd498603.png" alt="img"></a></p>
<h2 id="②应用场景"><a href="#②应用场景" class="headerlink" title="②应用场景"></a>②应用场景</h2><p>在Server模式下，ParNew收集器是一个非常重要的收集器，因为除Serial外，目前只有它<strong>能与CMS收集器配合工作</strong>；</p>
<p>但在单个CPU环境中，不会比Serail收集器有更好的效果，因为存在线程交互开销。</p>
<h2 id="③设置参数"><a href="#③设置参数" class="headerlink" title="③设置参数"></a>③设置参数</h2><p>​      <strong>“-XX:+UseConcMarkSweepGC”</strong>：指定使用CMS后，会默认使用ParNew作为新生代收集器；</p>
<p>​      <strong>“-XX:+UseParNewGC”</strong>：强制指定使用ParNew；</p>
<p>​      <strong>“-XX:ParallelGCThreads”</strong>：指定垃圾收集的线程数量，ParNew默认开启的收集线程与CPU的数量相同；</p>
<h2 id="④为什么只有ParNew能与CMS收集器配合"><a href="#④为什么只有ParNew能与CMS收集器配合" class="headerlink" title="④为什么只有ParNew能与CMS收集器配合"></a>④为什么只有ParNew能与CMS收集器配合</h2><p>CMS是HotSpot在JDK1.5推出的第一款真正意义上的并发（Concurrent）收集器，第一次实现了让垃圾收集线程与用户线程（基本上）同时工作；</p>
<p>CMS作为老年代收集器，但却无法与JDK1.4已经存在的新生代收集器Parallel Scavenge配合工作；</p>
<p>因为Parallel Scavenge（以及G1）都没有使用传统的GC收集器代码框架，而另外独立实现；而其余几种收集器则共用了部分的框架代码；</p>
<h1 id="3-Parallel-Scavenge收集器"><a href="#3-Parallel-Scavenge收集器" class="headerlink" title="3.Parallel Scavenge收集器"></a>3.Parallel Scavenge收集器</h1><p><img src="https://raw.githubusercontent.com/hufanglei/img-csdn/main/img/2025-1-13/f3c04d4db2588ea1e09c80faea63aa28_1737626826179.png" alt="在这里插入图片描述"></p>
<p>文章链接：<a target="_blank" rel="noopener" href="https://www.jianshu.com/p/29460c44c664">https://www.jianshu.com/p/29460c44c664</a></p>
<p>Parallel是采用复制算法的多线程新生代垃圾回收器，似乎和ParNew收集器有很多的相似的地方。但是Parallel Scanvenge收集器的一个特点是它所关注的目标是吞吐量(Throughput)。所谓吞吐量就是CPU用于运行用户代码的时间与CPU总消耗时间的比值，即吞吐量&#x3D;运行用户代码时间 &#x2F; (运行用户代码时间 + 垃圾收集时间)。停顿时间越短就越适合需要与用户交互的程序，良好的响应速度能够提升用户的体验；而高吞吐量则可以最高效率地利用CPU时间，尽快地完成程序的运算任务，主要适合在后台运算而不需要太多交互的任务。</p>
<p>Parallel Old收集器是Parallel Scavenge收集器的老年代版本，采用多线程和”标记－整理”算法。这个收集器是在jdk1.6中才开始提供的，在此之前，新生代的Parallel Scavenge收集器一直处于比较尴尬的状态。原因是如果新生代Parallel Scavenge收集器，那么老年代除了Serial Old(PS MarkSweep)收集器外别无选择。由于单线程的老年代Serial Old收集器在服务端应用性能上的”拖累“，即使使用了Parallel Scavenge收集器也未必能在整体应用上获得吞吐量最大化的效果，又因为老年代收集中无法充分利用服务器多CPU的处理能力，在老年代很大而且硬件比较高级的环境中，这种组合的吞吐量甚至还不一定有ParNew加CMS的组合”给力“。直到Parallel Old收集器出现后，”吞吐量优先“收集器终于有了比较名副其实的应用，在注重吞吐量及CPU资源敏感的场合，都可以优先考虑Parallel Scavenge加Parallel Old收集器。</p>
<p><code>-UseParallelGC</code>: 虚拟机运行在Server模式下的默认值，打开此开关后，使用Parallel Scavenge + Serial Old的收集器组合进行内存回收。-UseParallelOldGC: 打开此开关后，使用Parallel Scavenge + Parallel Old的收集器组合进行垃圾回收</p>
<p>文章链接：<a target="_blank" rel="noopener" href="https://www.breakyizhan.com/javamianshiti/2853.html">https://www.breakyizhan.com/javamianshiti/2853.html</a></p>
<p>Parallel Scavenge垃圾收集器因为与吞吐量关系密切，也称为吞吐量收集器（Throughput Collector）。</p>
<h2 id="①特点-2"><a href="#①特点-2" class="headerlink" title="①特点"></a>①特点</h2><hr>
<p>（A）、有一些特点与ParNew收集器相似</p>
<p>新生代收集器；</p>
<p>采用复制算法；</p>
<p>多线程收集；</p>
<p>（B）、主要特点是：它的关注点与其他收集器不同</p>
<p>CMS等收集器的关注点是尽可能地缩短垃圾收集时用户线程的停顿时间；</p>
<p>而Parallel Scavenge收集器的目标则是达一个可控制的吞吐量（Throughput）；</p>
<p>关于吞吐量与收集器关注点说明详见本节后面；</p>
<h2 id="②应用场景-1"><a href="#②应用场景-1" class="headerlink" title="②应用场景"></a>②应用场景</h2><hr>
<p>高吞吐量为目标，即减少垃圾收集时间，让用户代码获得更长的运行时间；</p>
<p>当应用程序运行在具有多个CPU上，对暂停时间没有特别高的要求时，即程序主要在后台进行计算，而不需要与用户进行太多交互；</p>
<p>例如，那些执行批量处理、订单处理、工资支付、科学计算的应用程序；</p>
<h2 id="③设置参数-1"><a href="#③设置参数-1" class="headerlink" title="③设置参数"></a>③设置参数</h2><hr>
<p>Parallel Scavenge收集器提供两个参数用于精确控制吞吐量：</p>
<p>（A）、”-XX:MaxGCPauseMillis”</p>
<p>控制最大垃圾收集停顿时间，大于0的毫秒数；</p>
<p>MaxGCPauseMillis设置得稍小，停顿时间可能会缩短，但也可能会使得吞吐量下降；</p>
<p>因为可能导致垃圾收集发生得更频繁；</p>
<p>（B）、”-XX:GCTimeRatio”</p>
<p>设置垃圾收集时间占总时间的比率，0&lt;n&lt;100的整数；</p>
<p>GCTimeRatio相当于设置吞吐量大小；</p>
<p>垃圾收集执行时间占应用程序执行时间的比例的计算方法是：</p>
<p>1 &#x2F; (1 + n)</p>
<p>例如，选项-XX:GCTimeRatio&#x3D;19，设置了垃圾收集时间占总时间的5%–1&#x2F;(1+19)；</p>
<p>默认值是1%–1&#x2F;(1+99)，即n&#x3D;99；</p>
<p>垃圾收集所花费的时间是年轻一代和老年代收集的总时间；</p>
<p>如果没有满足吞吐量目标，则增加代的内存大小以尽量增加用户程序运行的时间；</p>
<p>此外，还有一个值得关注的参数：</p>
<p>（C）、”-XX:+UseAdptiveSizePolicy”</p>
<p>开启这个参数后，就不用手工指定一些细节参数，如：</p>
<p>新生代的大小（-Xmn）、Eden与Survivor区的比例（-XX:SurvivorRation）、晋升老年代的对象年龄（-XX:PretenureSizeThreshold）等；</p>
<p>JVM会根据当前系统运行情况收集性能监控信息，动态调整这些参数，以提供最合适的停顿时间或最大的吞吐量，这种调节方式称为GC自适应的调节策略（GC Ergonomiscs）；</p>
<p>这是一种值得推荐的方式：</p>
<p>(1)、只需设置好内存数据大小（如”-Xmx”设置最大堆）；</p>
<p>(2)、然后使用”-XX:MaxGCPauseMillis”或”-XX:GCTimeRatio”给JVM设置一个优化目标；</p>
<p>(3)、那些具体细节参数的调节就由JVM自适应完成；</p>
<p>这也是Parallel Scavenge收集器与ParNew收集器一个重要区别；</p>
<p>更多目标调优和GC自适应的调节策略说明请参考：</p>
<p>《Memory Management in the Java HotSpot™ Virtual Machine》 5节 Ergonomics – Automatic Selections and Behavior Tuning：<a target="_blank" rel="noopener" href="http://www.oracle.com/technetwork/java/javase/tech/memorymanagement-whitepaper-1-150020.pdf">http://www.oracle.com/technetwork/java/javase/tech/memorymanagement-whitepaper-1-150020.pdf</a></p>
<p>《Java Platform, Standard Edition HotSpot Virtual Machine Garbage Collection Tuning Guide》 第2节 Ergonomics：<a target="_blank" rel="noopener" href="http://docs.oracle.com/javase/8/docs/technotes/guides/vm/gctuning/ergonomics.html#ergonomics">http://docs.oracle.com/javase/8/docs/technotes/guides/vm/gctuning/ergonomics.html#ergonomics</a></p>
<h2 id="④吞吐量与收集器关注点说明"><a href="#④吞吐量与收集器关注点说明" class="headerlink" title="④吞吐量与收集器关注点说明"></a>④吞吐量与收集器关注点说明</h2><hr>
<h3 id="A）、吞吐量（Throughput）"><a href="#A）、吞吐量（Throughput）" class="headerlink" title="A）、吞吐量（Throughput）"></a>A）、吞吐量（Throughput）</h3><p>CPU用于运行用户代码的时间与CPU总消耗时间的比值；</p>
<p>即吞吐量&#x3D;运行用户代码时间&#x2F;（运行用户代码时间+垃圾收集时间）；</p>
<p>高吞吐量即减少垃圾收集时间，让用户代码获得更长的运行时间；</p>
<h3 id="B）、垃圾收集器期望的目标（关注点）"><a href="#B）、垃圾收集器期望的目标（关注点）" class="headerlink" title="B）、垃圾收集器期望的目标（关注点）"></a>B）、垃圾收集器期望的目标（关注点）</h3><h4 id="1）、停顿时间"><a href="#1）、停顿时间" class="headerlink" title="1）、停顿时间"></a>1）、停顿时间</h4><p>停顿时间越短就适合需要与用户交互的程序；</p>
<p>良好的响应速度能提升用户体验；</p>
<h4 id="2）、吞吐量"><a href="#2）、吞吐量" class="headerlink" title="2）、吞吐量"></a>2）、吞吐量</h4><p>高吞吐量则可以高效率地利用CPU时间，尽快完成运算的任务；</p>
<p>主要适合在后台计算而不需要太多交互的任务；</p>
<h4 id="3）、覆盖区（Footprint）"><a href="#3）、覆盖区（Footprint）" class="headerlink" title="3）、覆盖区（Footprint）"></a>3）、覆盖区（Footprint）</h4><p>在达到前面两个目标的情况下，尽量减少堆的内存空间；</p>
<p>可以获得更好的空间局部性；</p>
<hr>
<p>完</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://hufanglei.github.io/2019/12/30/jvm(7)%20--%20%E5%A6%82%E4%BD%95%E5%9B%9E%E6%94%B6%E5%9E%83%E5%9C%BE%E5%AF%B9%E8%B1%A1%E3%80%81%E5%9B%9E%E6%94%B6%E7%AE%97%E6%B3%95%E7%AD%96%E7%95%A5/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="胡方雷">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="个人博客">
      <meta itemprop="description" content="直到这一刻微笑着说话为止，我至少留下了一公升眼泪">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | 个人博客">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2019/12/30/jvm(7)%20--%20%E5%A6%82%E4%BD%95%E5%9B%9E%E6%94%B6%E5%9E%83%E5%9C%BE%E5%AF%B9%E8%B1%A1%E3%80%81%E5%9B%9E%E6%94%B6%E7%AE%97%E6%B3%95%E7%AD%96%E7%95%A5/" class="post-title-link" itemprop="url">jvm(7) -- 如何回收垃圾对象、回收算法策略</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2019-12-30 11:41:45" itemprop="dateCreated datePublished" datetime="2019-12-30T11:41:45+08:00">2019-12-30</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2025-01-24 11:37:59" itemprop="dateModified" datetime="2025-01-24T11:37:59+08:00">2025-01-24</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/jvm/" itemprop="url" rel="index"><span itemprop="name">jvm</span></a>
        </span>
    </span>

  
    <span class="post-meta-break"></span>
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>1.1k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>1 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <span id="more"></span>

<p>@[toc]</p>
<h1 id="①、标记-清除算法"><a href="#①、标记-清除算法" class="headerlink" title="①、标记 -清除算法"></a>①、标记 -清除算法</h1><p>“标记-清除”（Mark-Sweep）算法，如它的名字一样，算法分为“标记”和“清除”两个阶段：首先标记出所有需要回收的对象，在标记完成后统一回收掉所有被标记的对象。之所以说它是最基础的收集算法，是因为后续的收集算法都是基于这种思路并对其缺点进行改进而得到的。</p>
<p>它的主要缺点有两个：</p>
<h3 id="a-效率问题"><a href="#a-效率问题" class="headerlink" title="a.效率问题"></a>a.效率问题</h3><p>标记和清除过程的效率都不高；</p>
<h3 id="b-空间问题"><a href="#b-空间问题" class="headerlink" title="b.空间问题"></a>b.空间问题</h3><p>标记清除之后会产生大量不连续的内存碎片，空间碎片太多可能会导致，当程序在以后的运行过程中需要分配较大对象时无法找到足够的连续内存而不得不提前触发另一次垃圾收集动作。<br><img src="https://raw.githubusercontent.com/hufanglei/img-csdn/main/img/2025-1-13/9d94d6b97bf094848e5463a1986c852f_1737626826179.png" alt="在这里插入图片描述"></p>
<h1 id="②-复制算法"><a href="#②-复制算法" class="headerlink" title="②.复制算法"></a>②.复制算法</h1><p>“复制”（Copying）的收集算法，它将可用内存按容量划分为<strong>大小相等</strong>的两块，每次只使用其中的一块。当这一块的内存用完了，就将还存活着的对象复制到另外一块上面，然后再把已使用过的内存空间一次清理掉。</p>
<p>这样使得每次都是对其中的一块进行内存回收，内存分配时也就不用考虑内存碎片等复杂情况，只要移动堆顶指针，按顺序分配内存即可，实现简单，运行高效。只是这种算法的代价是将内存缩小为原来的一半，降低了内存的利用率，持续复制长生存期的对象则导致效率降低，还有在分配对象较大时，该种算法也存在效率低下的问题。</p>
<p><img src="https://raw.githubusercontent.com/hufanglei/img-csdn/main/img/2025-1-13/6ec0fbfecffaf55561201f9449cc751e_1737626826179.png" alt="在这里插入图片描述"></p>
<h2 id="深入理解-堆内存使用的复制算法场景-新生代中"><a href="#深入理解-堆内存使用的复制算法场景-新生代中" class="headerlink" title="深入理解:堆内存使用的复制算法场景:新生代中"></a>深入理解:堆内存使用的复制算法场景:新生代中</h2><p><img src="https://i-blog.csdnimg.cn/blog_migrate/6ec0fbfecffaf55561201f9449cc751e.png" alt="在这里插入图片描述"></p>
<p>参考文章:</p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/iceframemo/article/details/79897065">jvm垃圾回收之复制算法——为什么分两块Survivor空间</a></p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/antony9118/article/details/51425581">为什么新生代内存需要有两个Survivor区</a></p>
<h1 id="③-标记-整理算法"><a href="#③-标记-整理算法" class="headerlink" title="③.标记-整理算法"></a>③.标记-整理算法</h1><p>   复制收集算法在对象存活率较高时就要执行较多的复制操作，效率将会变低。更关键的是，如果不想浪费50%的空间，就需要有额外的空间进行分配担保，以应对被使用的内存中所有对象都100%存活的极端情况，所以在老年代一般不能直接选用这种算法。<br>​    根据老年代的特点，有人提出了另外一种“标记-整理”（Mark-Compact）算法，标记过程仍然与“标记-清除”算法一样，但后续步骤不是直接对可回收对象进行清理，而是让所有存活的对象都向一端移动，然后直接清理掉端边界以外的内存。<br><img src="https://raw.githubusercontent.com/hufanglei/img-csdn/main/img/2025-1-13/e3837269bf90f8004263061f31a75a5e_1737626836550.png" alt="在这里插入图片描述"></p>
<h1 id="④分代收集算法"><a href="#④分代收集算法" class="headerlink" title="④分代收集算法"></a>④分代收集算法</h1><p>JVM对内存Heap的不同区域采用不同的算法。</p>
<p>主要是新生代和年老代，新生代比较适合复制算法，新生代有Eden&#x2F;From&#x2F;To，采用复制算法，速度非常快。Eden中存活的对象会被复制到To区域。</p>
<p>老年代的对象的生命周期比较长，不适合复制算法，在老年代中一般采用标记&#x2F;整理(压缩)算法。首先标记出老年代中的垃圾对象，然后将存活对象移动到一个连续的区域。Full GC将没有用的垃圾对象清除，存活的对象是一块连续的空间。垃圾对象也有一个具体的地址，为下一次对象分配的指针，将新对象分配到空闲的位置。</p>
<hr>
<p>完</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://hufanglei.github.io/2019/12/30/jvm(6)%20--%20%E5%A6%82%E4%BD%95%E5%88%A4%E5%AE%9A%E5%AF%B9%E8%B1%A1%E4%B8%BA%E5%9E%83%E5%9C%BE%E5%AF%B9%E8%B1%A1(%E6%98%AF%E5%90%A6%E5%AD%98%E6%B4%BB)/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="胡方雷">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="个人博客">
      <meta itemprop="description" content="直到这一刻微笑着说话为止，我至少留下了一公升眼泪">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | 个人博客">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2019/12/30/jvm(6)%20--%20%E5%A6%82%E4%BD%95%E5%88%A4%E5%AE%9A%E5%AF%B9%E8%B1%A1%E4%B8%BA%E5%9E%83%E5%9C%BE%E5%AF%B9%E8%B1%A1(%E6%98%AF%E5%90%A6%E5%AD%98%E6%B4%BB)/" class="post-title-link" itemprop="url">jvm(6) -- 如何判定对象为垃圾对象(是否存活)</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2019-12-30 10:46:32" itemprop="dateCreated datePublished" datetime="2019-12-30T10:46:32+08:00">2019-12-30</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2025-01-24 11:37:59" itemprop="dateModified" datetime="2025-01-24T11:37:59+08:00">2025-01-24</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/jvm/" itemprop="url" rel="index"><span itemprop="name">jvm</span></a>
        </span>
    </span>

  
    <span class="post-meta-break"></span>
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>4.8k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>4 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <span id="more"></span>

<p>@[toc]</p>
<blockquote>
<p>转载 <a target="_blank" rel="noopener" href="https://blog.csdn.net/anyway8090/article/details/94297020">https://blog.csdn.net/anyway8090/article/details/94297020</a></p>
</blockquote>
<p>  堆中几乎存放着Java世界中所有的对象实例，垃圾收集器在对堆回收之前，第一件事情就是要确定这些对象哪些还“存活”着，哪些对象已经“死去”(即不可能再被任何途径使用的对象)。</p>
<h1 id="1、引用计数算法-Reference-Counting"><a href="#1、引用计数算法-Reference-Counting" class="headerlink" title="1、引用计数算法(Reference Counting)"></a>1、引用计数算法(Reference Counting)</h1><p> 很多教科书判断对象是否存活的算法是这样的：给对象中添加一个引用计数器，每当有一个地方引用它时，计数器值加1；当引用失效时，计数器减1；任何时刻计数器都为0的对象就是不可能再被使用的。<br>    引用计数算法的实现简单，判断效率也很高，在大部分情况下它都是一个不错的算法。但是Java语言中没有选用引用计数算法来管理内存，其中最主要的一个原因是它很难解决对象之间相互循环引用的问题。<br>    例如：<br>    在testGC()方法中，对象objA和objB都有字段instance，赋值令objA.instance&#x3D;objB及objB.instance&#x3D;objA，除此之外这两个对象再无任何引用，实际上这两个对象都已经不能再被访问，但是它们因为相互引用着对象方，异常它们的引用计数都不为0，于是引用计数算法无法通知GC收集器回收它们。<br>    打印GC详细信息：<br>    -XX:+PrintGCDetails<br>    <img src="https://raw.githubusercontent.com/hufanglei/img-csdn/main/img/2025-1-13/f85de3aab352d6cea197ee63aae97149_1737626836550.png" alt="在这里插入图片描述"><br> idea配置: Run  -&gt; Run configurations -&gt; java应用名 -&gt; arguments -&gt;VM arguments，加入jvm参数就行</p>
<p>输入VM arguments参数：</p>
<blockquote>
<p><code>-Xms20m --jvm堆的最小值 </code><br>-<code>Xmx20m --jvm堆的最大值 </code><br><code>-XX:+PrintGCTimeStamps -- 打印出GC的时间信息  </code><br>-<code>XX:+PrintGCDetails  --打印出GC的详细信息  </code><br>-<code>verbose:gc --开启gc日志  </code><br>-<code>Xloggc:d:/gc.log -- gc日志的存放位置  </code><br>-<code>Xmn10M -- 新生代内存区域的大小  </code><br>-<code>XX:SurvivorRatio=8 --新生代内存区域中Eden和Survivor的比例</code></p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 执行后，objA和objB会不会被GC呢？</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ReferenceCountingGC</span> &#123;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">public</span> <span class="type">Object</span> <span class="variable">instance</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 这个成员属性的唯一意义就是占点内存，以便能在GC日志中看清楚是否被回收过</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">byte</span>[] bigSize = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">2</span> * <span class="number">1024</span> * <span class="number">1024</span>];</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">ReferenceCountingGC</span> <span class="variable">objA</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReferenceCountingGC</span>();</span><br><span class="line">        <span class="type">ReferenceCountingGC</span> <span class="variable">objB</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReferenceCountingGC</span>();</span><br><span class="line">        objA.instance = objB;</span><br><span class="line">        objB.instance = objA;</span><br><span class="line"> </span><br><span class="line">        objA = <span class="literal">null</span>;</span><br><span class="line">        objB = <span class="literal">null</span>;</span><br><span class="line"> </span><br><span class="line">        <span class="comment">//假设在这行发生了GC，objA和ojbB是否被回收</span></span><br><span class="line">        System.gc();</span><br><span class="line">        <span class="comment">//1.8采用Parallel GC</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>[GC (Allocation Failure) [DefNew: 3707K-&gt;512K(4928K), 0.0041893 secs] 3707K-&gt;1214K(15872K), 0.0042359 secs] [Times: user&#x3D;0.02 sys&#x3D;0.00, real&#x3D;0.00 secs]<br>[Full GC (System.gc()) [Tenured: 702K-&gt;1216K(10944K), 0.0039473 secs] 5529K-&gt;1216K(15872K), [Metaspace: 2223K-&gt;2223K(4480K)], 0.0039998 secs] [Times: user&#x3D;0.00 sys&#x3D;0.00, real&#x3D;0.00 secs]<br>Heap<br> def new generation   total 4992K, used 45K [0x04600000, 0x04b60000, 0x09b50000)<br>  eden space 4480K,   1% used [0x04600000, 0x04612f10, 0x04a60000)<br>  from space 512K,   0% used [0x04a60000, 0x04a60000, 0x04ae0000)<br>  to   space 512K,   0% used [0x04ae0000, 0x04ae0000, 0x04b60000)<br> tenured generation   total 10944K, used 1216K [0x09b50000, 0x0a600000, 0x14600000)<br>   the space 10944K,  11% used [0x09b50000, 0x09c80108, 0x09c80200, 0x0a600000)<br> Metaspace       used 2228K, capacity 2280K, committed 2368K, reserved 4480K</p>
<hr>
<p>  在运行结果中可以看到：<br>  GC日志中包含”3707K-&gt;512K”，老年代从3707K(大约3.5M，其实就是objA与objB)变为了512K，意味着虚拟并没有因为这两个对象相互引用就不回收它们，这也<code>证明虚拟机并不是通过通过引用计数算法来判断对象是否存活的</code>。<br>  大家可以看到对象进入了老年代，<br>  但是大家都知道，对象刚创建的时候是分配在新生代中的，要进入老年代默认年龄要到了new objA才行，但这里objA与objB却进入了老年代。<br>  这是因为Java堆区会动态增长，刚开始时堆区较小，对象进入老年代还有一规则，当Survior空间中同一代的对象大小之和超过Survior空间的一半时，对象将直接进行老年代。</p>
<hr>
<h1 id="2、可达性分析算法-GC-Roots-Analysis-："><a href="#2、可达性分析算法-GC-Roots-Analysis-：" class="headerlink" title="2、可达性分析算法(GC Roots Analysis)："></a>2、可达性分析算法(GC Roots Analysis)：</h1><p><code>主流用这个判断。</code></p>
<p> 在主流的商用程序语言中(Java和C#)，都是使用可达性分析算法判断对象是否存活的。这个算法的基本思路就是通过一系列名为”GC Roots”的对象作为起始点，从这些节点开始向下搜索，搜索所走过的路径称为引用链(Reference Chain)，当一个对象到GC Roots没有任何引用链相连时，则证明此对象是不可用的，下图对象object5, object6, object7虽然有互相判断，但它们到GC Roots是不可达的，所以它们将会判定为是可回收对象。<br> <img src="https://raw.githubusercontent.com/hufanglei/img-csdn/main/img/2025-1-13/94d722943301e43325266a36186c7dbf_1737626836550.png" alt="在这里插入图片描述"><br>   在Java语言里，可作为GC Roots对象的包括如下几种：</p>
<ul>
<li>a.虚拟机栈(栈桢中的本地变量表)中的引用的对象</li>
<li>b.方法区中的类静态属性引用的对象</li>
<li>c.方法区中的常量引用的对象</li>
<li>d.本地方法栈中JNI的引用的对象</li>
</ul>
<h1 id="3-finalize-方法最终判定对象是否存活"><a href="#3-finalize-方法最终判定对象是否存活" class="headerlink" title="3.finalize()方法最终判定对象是否存活"></a>3.finalize()方法最终判定对象是否存活</h1><p> 即使在可达性分析算法中不可达的对象，也并非是“非死不可”的，这时候它们暂时处于“缓刑”阶段，要真正宣告一个对象死亡，至少要经历再次标记过程。</p>
<p>标记的前提是对象在进行可达性分析后发现没有与GC Roots相连接的引用链。</p>
<h2 id="1-第一次标记并进行一次筛选。"><a href="#1-第一次标记并进行一次筛选。" class="headerlink" title="1).第一次标记并进行一次筛选。"></a>1).第一次标记并进行一次筛选。</h2><p>   筛选的条件是此对象是否有必要执行finalize()方法。<br>   当对象没有覆盖finalize方法，或者finzlize方法已经被虚拟机调用过，虚拟机将这两种情况都视为“没有必要执行”，对象被回收。</p>
<h2 id="2-第二次标记"><a href="#2-第二次标记" class="headerlink" title="2).第二次标记"></a>2).第二次标记</h2><p>  如果这个对象被判定为有必要执行finalize（）方法，那么这个对象将会被放置在一个名为：F-Queue的队列之中，并在稍后由一条虚拟机自动建立的、低优先级的Finalizer线程去执行。这里所谓的“执行”是指虚拟机会触发这个方法，但并不承诺会等待它运行结束。这样做的原因是，如果一个对象finalize（）方法中执行缓慢，或者发生死循环（更极端的情况），将很可能会导致F-Queue队列中的其他对象永久处于等待状态，甚至导致整个内存回收系统崩溃。</p>
<p>  Finalize（）方法是对象脱逃死亡命运的最后一次机会，稍后GC将对F-Queue中的对象进行第二次小规模标记，如果对象要在finalize（）中成功拯救自己—-只要重新与引用链上的任何的一个对象建立关联即可，譬如把自己赋值给某个类变量或对象的成员变量，那在第二次标记时它将移除出“即将回收”的集合。如果对象这时候还没逃脱，那基本上它就真的被回收了。</p>
<p>流程图如下：</p>
<p><img src="https://raw.githubusercontent.com/hufanglei/img-csdn/main/img/2025-1-13/ed12ce44cdbb47b87e2431afa7ce22ad_1737626836550.png" alt="在这里插入图片描述"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 此代码演示了两点</span></span><br><span class="line"><span class="comment"> * 1、对象可以在被GC时自我拯救</span></span><br><span class="line"><span class="comment"> * 2、这种自救的机会只有一次，因为一个对象的finalize()方法最多只能被系统自动调用一次。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FinalizeEscapeGC</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">FinalizeEscapeGC</span> <span class="variable">SAVE_HOOK</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">isAlive</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;yes, I am still alive&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">finalize</span><span class="params">()</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line">        <span class="built_in">super</span>.finalize();</span><br><span class="line">        System.out.println(<span class="string">&quot;finalize method executed!&quot;</span>);</span><br><span class="line">        FinalizeEscapeGC.SAVE_HOOK = <span class="built_in">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        SAVE_HOOK = <span class="keyword">new</span> <span class="title class_">FinalizeEscapeGC</span>();</span><br><span class="line"> </span><br><span class="line">        <span class="comment">//对象第一次成功拯救自己</span></span><br><span class="line">        SAVE_HOOK = <span class="literal">null</span>;</span><br><span class="line">        System.gc();</span><br><span class="line"> </span><br><span class="line">        <span class="comment">//因为finalize方法优先级很低，所有暂停0.5秒以等待它</span></span><br><span class="line">        Thread.sleep(<span class="number">500</span>);</span><br><span class="line">        <span class="keyword">if</span> (SAVE_HOOK != <span class="literal">null</span>) &#123;</span><br><span class="line">            SAVE_HOOK.isAlive();</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;no ,I am dead QAQ!&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">        <span class="comment">//-----------------------</span></span><br><span class="line">        <span class="comment">//以上代码与上面的完全相同,但这次自救却失败了！！！</span></span><br><span class="line">        SAVE_HOOK = <span class="literal">null</span>;</span><br><span class="line">        System.gc();</span><br><span class="line"> </span><br><span class="line">        <span class="comment">//因为finalize方法优先级很低，所有暂停0.5秒以等待它</span></span><br><span class="line">        Thread.sleep(<span class="number">500</span>);</span><br><span class="line">        <span class="keyword">if</span> (SAVE_HOOK != <span class="literal">null</span>) &#123;</span><br><span class="line">            SAVE_HOOK.isAlive();</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;no ,I am dead QAQ!&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"></span><br></pre></td></tr></table></figure>
<blockquote>
<p>输出：<br>finalize method executed!<br>yes, I am still alive<br>no ,I am dead QAQ!</p>
</blockquote>
<p>理解这篇文章，还要有对finalize的认识:<br>推荐文章: <a target="_blank" rel="noopener" href="https://www.cnblogs.com/Smina/p/7189427.html">java finalize方法总结、GC执行finalize的过程</a></p>
<p>从结果可以看出，SAVE_HOOK对象的finalize()方法确实被GC收集器触发过，并且在被收集前成功逃脱了。<br>注意：任何一个对象的finalize()方法都只会被系统自动调用一次，如果对象面临下一次回收，它的finalize()方法不会被再次执行，因此第二段代码的自救行动失败了。 并且建议大家尽量避免使用它 。</p>
<hr>
<p>完</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://hufanglei.github.io/2019/12/30/%E8%BF%9B%E9%98%B6%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F(1)%20--%20%E7%AE%80%E5%8D%95%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F%E8%BD%AC%E8%BD%BD%E5%A5%BD%E6%96%87%E7%AB%A0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="胡方雷">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="个人博客">
      <meta itemprop="description" content="直到这一刻微笑着说话为止，我至少留下了一公升眼泪">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | 个人博客">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2019/12/30/%E8%BF%9B%E9%98%B6%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F(1)%20--%20%E7%AE%80%E5%8D%95%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F%E8%BD%AC%E8%BD%BD%E5%A5%BD%E6%96%87%E7%AB%A0/" class="post-title-link" itemprop="url">进阶设计模式(1) -- 简单工厂模式转载好文章</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2019-12-30 08:51:18" itemprop="dateCreated datePublished" datetime="2019-12-30T08:51:18+08:00">2019-12-30</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2025-01-24 11:37:59" itemprop="dateModified" datetime="2025-01-24T11:37:59+08:00">2025-01-24</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/" itemprop="url" rel="index"><span itemprop="name">设计模式</span></a>
        </span>
    </span>

  
    <span class="post-meta-break"></span>
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>55</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>1 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <span id="more"></span>


<p>转载: <a target="_blank" rel="noopener" href="https://www.cnblogs.com/kubixuesheng/p/10344427.html">https://www.cnblogs.com/kubixuesheng/p/10344427.html</a></p>
<p><img src="https://raw.githubusercontent.com/hufanglei/img-csdn/main/img/2025-1-13/3a036178276379e84d6d772dbb6a99ac_1737626836550.png" alt="在这里插入图片描述"></p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://hufanglei.github.io/2019/12/29/jvm(5)%20--%20%E5%AF%B9%E8%B1%A1%E7%9A%84%E8%AE%BF%E9%97%AE%E5%AE%9A%E4%BD%8D/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="胡方雷">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="个人博客">
      <meta itemprop="description" content="直到这一刻微笑着说话为止，我至少留下了一公升眼泪">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | 个人博客">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2019/12/29/jvm(5)%20--%20%E5%AF%B9%E8%B1%A1%E7%9A%84%E8%AE%BF%E9%97%AE%E5%AE%9A%E4%BD%8D/" class="post-title-link" itemprop="url">jvm(5) -- 对象的访问定位</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2019-12-29 23:25:56" itemprop="dateCreated datePublished" datetime="2019-12-29T23:25:56+08:00">2019-12-29</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2025-01-24 11:37:59" itemprop="dateModified" datetime="2025-01-24T11:37:59+08:00">2025-01-24</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/jvm/" itemprop="url" rel="index"><span itemprop="name">jvm</span></a>
        </span>
    </span>

  
    <span class="post-meta-break"></span>
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>565</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>1 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <span id="more"></span>

<p>@[toc]<br>文章来自:链接：<a target="_blank" rel="noopener" href="https://www.jianshu.com/p/4ca9dae303c8">https://www.jianshu.com/p/4ca9dae303c8</a></p>
<blockquote>
<p>建立对象是为了使用对象，我们的Java程序需要通过栈上的reference数据来操作堆上的具体对象。<br>由于reference类型在Java虚拟机规范中只规定了一个指向对象的引用，并没有定义这个引用应该通过何种方式定位，访问堆中的对象的具体位置，所以对象访问方式也取决于虚拟机实现而定的。</p>
<p>目前主流的访问方式有<code>使用句柄</code>和<code>直接指针</code>两种。</p>
</blockquote>
<h1 id="句柄访问"><a href="#句柄访问" class="headerlink" title="句柄访问"></a>句柄访问</h1><p>Java堆中将划分出一块内存来作为句柄池，reference中储存的就是就是对象的句柄地址，而句柄中包含了对象的实例数据与数据类型的数据各自的具体地址信息。</p>
<p><img src="https://raw.githubusercontent.com/hufanglei/img-csdn/main/img/2025-1-13/f85c3d98cc4259cc16dc8cd22695e490_1737626848104.png" alt="在这里插入图片描述"></p>
<h1 id="直接指针"><a href="#直接指针" class="headerlink" title="直接指针"></a>直接指针</h1><p>Java堆对象的布局就必须考虑如何放置访问类型数据的相关信息，而peference中储存的直接就是对象地址。<br><img src="https://raw.githubusercontent.com/hufanglei/img-csdn/main/img/2025-1-13/55682bd7732ea1e9af9150616afa467c_1737626848104.png" alt="在这里插入图片描述"></p>
<h1 id="对比"><a href="#对比" class="headerlink" title="对比"></a>对比</h1><p>这两种对象访问各有优势:<br>使用句柄来访问的最大好处是<code>reference中储存的是稳定的句柄地址</code>，<code>在对象被移动（垃圾收集时移动对象是非常普遍的行为）时只会改变句柄中的实例数据指针</code>，而reference本身不需要修改。<br>使用直接指针的最大好处就是<code>速度更快，它节省了一次指针定位的时间开销，由于对象的访问在Java中非常频繁，因此这类开销积少成多后也是一项非常可观的执行成本</code>。HotSpot使用的是第二种方式进行对象访问。</p>
<hr>
<p>完</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://hufanglei.github.io/2019/12/29/jvm(4)%20--%20java%E5%AF%B9%E8%B1%A1%E7%9A%84%E7%BB%93%E6%9E%84/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="胡方雷">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="个人博客">
      <meta itemprop="description" content="直到这一刻微笑着说话为止，我至少留下了一公升眼泪">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | 个人博客">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2019/12/29/jvm(4)%20--%20java%E5%AF%B9%E8%B1%A1%E7%9A%84%E7%BB%93%E6%9E%84/" class="post-title-link" itemprop="url">jvm(4) -- java对象的结构</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2019-12-29 22:58:50" itemprop="dateCreated datePublished" datetime="2019-12-29T22:58:50+08:00">2019-12-29</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2025-01-24 11:37:59" itemprop="dateModified" datetime="2025-01-24T11:37:59+08:00">2025-01-24</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/jvm/" itemprop="url" rel="index"><span itemprop="name">jvm</span></a>
        </span>
    </span>

  
    <span class="post-meta-break"></span>
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>833</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>1 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <span id="more"></span>

<p>@[toc]<br>来自:<a target="_blank" rel="noopener" href="https://blog.csdn.net/itcats_cn/article/details/80949112">https://blog.csdn.net/itcats_cn/article/details/80949112</a></p>
<blockquote>
<p>java对象的结构是由Header对象头、InstanceData、Padding组成</p>
</blockquote>
<h1 id="一、Header-对象头"><a href="#一、Header-对象头" class="headerlink" title="一、Header(对象头)"></a>一、Header(对象头)</h1><h2 id="1、自身运行时的数据-Mark-Word"><a href="#1、自身运行时的数据-Mark-Word" class="headerlink" title="1、自身运行时的数据(Mark Word)"></a>1、自身运行时的数据(Mark Word)</h2><pre><code>  HotSpot虚拟机对象头     Mark Word
</code></pre>
<p> <img src="https://raw.githubusercontent.com/hufanglei/img-csdn/main/img/2025-1-13/9da67bf31e30bb1c11a754b9a037c8c2_1737626848104.png" alt="在这里插入图片描述"><br>(根据系统虚拟机大小不同其大小不同,32位虚拟机数据大小为32位，64位系统虚拟机数据大小为64位)。</p>
<p>存储内容:</p>
<ul>
<li><p>哈希值(hashCode()方法是native)</p>
<ul>
<li>GC分代年龄(为分代收集算法所服务   分代好处:针对各个年龄代特点，选择适当的垃圾收集算法。)</li>
<li>锁状态标志</li>
<li>线程持有的锁</li>
<li>偏向线程ID</li>
<li>偏向时间戳</li>
</ul>
</li>
</ul>
<h2 id="2、类型指针-Class-Metadata-Address"><a href="#2、类型指针-Class-Metadata-Address" class="headerlink" title="2、类型指针(Class Metadata Address)"></a>2、类型指针(Class Metadata Address)</h2><p>对象指向类的元数据的指针，虚拟机通过这个指针来确定对象是哪一个类的实例，并不是所有jvm实现都必须在对象数据上保留类型指针</p>
<pre><code>    3、作为普通对象的对象头结构只有以上两种，但如果对象是一个数组，则对象头中还包含记录数组长度的数据
</code></pre>
<h1 id="二、InstanceData"><a href="#二、InstanceData" class="headerlink" title="二、InstanceData"></a>二、InstanceData</h1><p>数据的实例信息，真正存储对象有效信息的部分，我们所接触最多的部分。<br>不管是从父类继承中获得的还是从子类定义的实例信息，都被记录在其中。<br>这部分的存储顺序由虚拟机的分配策略和字段在Java源码中定义的顺序决定，HotspotVM默认策略——相同宽度的字段分配到一起，如 long&#x2F;double类型、short&#x2F;char 分配到一起。<br>在父类中定义的对象，可能出现在子类之前。</p>
<h1 id="三、Padding"><a href="#三、Padding" class="headerlink" title="三、Padding"></a>三、Padding</h1><p> 这部分数据并不是必然存在的，它也没有特殊的含义。作用是作为一个占位符，用于填充内存。</p>
<h2 id="为什么需要padding"><a href="#为什么需要padding" class="headerlink" title="为什么需要padding?"></a>为什么需要padding?</h2><p> 主要因为HotspotVM自动内存管理系统要求对象起始地址必须是8个字节的整数倍，也就是说对象的大小必须是8个字节的整数倍，而对象头部分整好是8个字节的整数倍。因此，对象实例数据部分如果没有对齐是就需要通过padding来进行填充。</p>
<hr>
<p>完</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




  <nav class="pagination">
    <a class="extend prev" rel="prev" title="上一页" aria-label="上一页" href="/page/33/"><i class="fa fa-angle-left"></i></a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/33/">33</a><span class="page-number current">34</span><a class="page-number" href="/page/35/">35</a><span class="space">&hellip;</span><a class="page-number" href="/page/60/">60</a><a class="extend next" rel="next" title="下一页" aria-label="下一页" href="/page/35/"><i class="fa fa-angle-right"></i></a>
  </nav>

</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">

  <div class="copyright">
    &copy; 
    <span itemprop="copyrightYear">2025</span>
    <span class="with-love">
      <i class="fa fa-heart"></i>
    </span>
    <span class="author" itemprop="copyrightHolder">胡方雷</span>
  </div>
<div class="wordcount">
  <span class="post-meta-item">
    <span class="post-meta-item-icon">
      <i class="fa fa-chart-line"></i>
    </span>
      <span>站点总字数：</span>
    <span title="站点总字数">1.8m</span>
  </span>
  <span class="post-meta-item">
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
      <span>站点阅读时长 &asymp;</span>
    <span title="站点阅读时长">26:40</span>
  </span>
</div>
<div class="busuanzi-count">
    <span class="post-meta-item" id="busuanzi_container_site_uv">
      <span class="post-meta-item-icon">
        <i class="user"></i>
      </span>
      <span class="site-uv" title="总访客量">
        <span id="busuanzi_value_site_uv"></span>
      </span>
    </span>
    <span class="post-meta-item" id="busuanzi_container_site_pv">
      <span class="post-meta-item-icon">
        <i class="eye"></i>
      </span>
      <span class="site-pv" title="总访问量">
        <span id="busuanzi_value_site_pv"></span>
      </span>
    </span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/" rel="noopener" target="_blank">NexT.Gemini</a> 强力驱动
  </div>

    </div>
  </footer>

  
  <div class="toggle sidebar-toggle" role="button">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>
  <div class="sidebar-dimmer"></div>
  <div class="back-to-top" role="button" aria-label="返回顶部">
    <i class="fa fa-arrow-up fa-lg"></i>
    <span>0%</span>
  </div>

  <a href="https://github.com/hufanglei" class="github-corner" title="在 GitHub 上关注我" aria-label="在 GitHub 上关注我" rel="noopener" target="_blank"><svg width="80" height="80" viewBox="0 0 250 250" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg></a>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


  
  <script src="https://cdnjs.cloudflare.com/ajax/libs/animejs/3.2.1/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous"></script>
<script src="/js/comments.js"></script><script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/sidebar.js"></script><script src="/js/next-boot.js"></script>

  <script src="https://cdnjs.cloudflare.com/ajax/libs/hexo-generator-searchdb/1.4.1/search.js" integrity="sha256-1kfA5uHPf65M5cphT2dvymhkuyHPQp5A53EGZOnOLmc=" crossorigin="anonymous"></script>
<script src="/js/third-party/search/local-search.js"></script>







  
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>





</body>
</html>
