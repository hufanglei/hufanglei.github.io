<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222"><meta name="generator" content="Hexo 7.3.0">

  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.7.2/css/all.min.css" integrity="sha256-dABdfBfUoC8vJUBOwGVdm8L9qlMWaHTIfXt+7GnZCIo=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/animate.css/3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous">

<script class="next-config" data-name="main" type="application/json">{"hostname":"hufanglei.github.io","root":"/","images":"/images","scheme":"Gemini","darkmode":false,"version":"8.22.0","exturl":false,"sidebar":{"position":"left","width_expanded":320,"width_dual_column":240,"display":"post","padding":18,"offset":12,"scrollpercent":true,"onmobile":false},"hljswrap":true,"copycode":{"enable":true,"style":null},"fold":{"enable":false,"height":500},"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"stickytabs":false,"motion":{"enable":true,"async":false,"duration":200,"transition":{"menu_item":"fadeInDown","post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"},"path":"/search.xml","localsearch":{"enable":true,"top_n_per_article":1,"unescape":false,"preload":false}}</script><script src="/js/config.js"></script>

    <meta name="description" content="直到这一刻微笑着说话为止，我至少留下了一公升眼泪">
<meta property="og:type" content="blog">
<meta property="og:title" content="个人博客">
<meta property="og:url" content="https://hufanglei.github.io/page/31/index.html">
<meta property="og:site_name" content="个人博客">
<meta property="og:description" content="直到这一刻微笑着说话为止，我至少留下了一公升眼泪">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="胡方雷">
<meta name="twitter:card" content="summary">


<link rel="canonical" href="https://hufanglei.github.io/page/31/">


<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":true,"isPost":false,"lang":"zh-CN","comments":"","permalink":"","path":"page/31/index.html","title":""}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>个人博客</title>
  








  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <div class="column">
      <header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏" role="button">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <h1 class="site-title">个人博客</h1>
      <i class="logo-line"></i>
    </a>
      <p class="site-subtitle" itemprop="description">记录生活中的点点滴滴</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger" aria-label="搜索" role="button">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a></li><li class="menu-item menu-item-about"><a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a></li><li class="menu-item menu-item-tags"><a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签<span class="badge">398</span></a></li><li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类<span class="badge">105</span></a></li><li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档<span class="badge">594</span></a></li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
      <div class="search-header">
        <span class="search-icon">
          <i class="fa fa-search"></i>
        </span>
        <div class="search-input-container">
          <input autocomplete="off" autocapitalize="off" maxlength="80"
                placeholder="搜索..." spellcheck="false"
                type="search" class="search-input">
        </div>
        <span class="popup-btn-close" role="button">
          <i class="fa fa-times-circle"></i>
        </span>
      </div>
      <div class="search-result-container">
        <div class="search-result-icon">
          <i class="fa fa-spinner fa-pulse fa-5x"></i>
        </div>
      </div>
    </div>
  </div>

</header>
        
  
  <aside class="sidebar">

    <div class="sidebar-inner sidebar-overview-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="胡方雷"
      src="/images/avatar.gif">
  <p class="site-author-name" itemprop="name">胡方雷</p>
  <div class="site-description" itemprop="description">直到这一刻微笑着说话为止，我至少留下了一公升眼泪</div>
</div>
<div class="site-state-wrap animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        <a href="/archives/">
          <span class="site-state-item-count">594</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
          <a href="/categories/">
        <span class="site-state-item-count">105</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
          <a href="/tags/">
        <span class="site-state-item-count">398</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author animated">
      <span class="links-of-author-item">
        <a href="https://github.com/hufanglei" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;hufanglei" rel="noopener me" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="https://hufanglei.blog.csdn.net/" title="CSDN → https:&#x2F;&#x2F;hufanglei.blog.csdn.net" rel="noopener me" target="_blank"><i class="crosshairs fa-fw"></i>CSDN</a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:690328661@qq.com" title="E-Mail → mailto:690328661@qq.com" rel="noopener me" target="_blank"><i class="fa fa-envelope fa-fw"></i>E-Mail</a>
      </span>
  </div>
  <div class="cc-license animated" itemprop="license">
    <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" class="cc-opacity" rel="noopener" target="_blank"><img src="https://cdnjs.cloudflare.com/ajax/libs/creativecommons-vocabulary/2020.11.3/assets/license_badges/small/by_nc_sa.svg" alt="Creative Commons"></a>
  </div>

        </div>
      </div>
    </div>

    <iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width=330 height=86 src="//music.163.com/outchain/player?type=2&id=1518938&auto=1&height=66"></iframe>

    
    <div class="sidebar-inner sidebar-blogroll">
      <div class="links-of-blogroll animated">
        <div class="links-of-blogroll-title">
          链接
        </div>
        <ul class="links-of-blogroll-list">
            <li class="links-of-blogroll-item">
              <a href="http://www.alloyteam.com/nav/" title="http:&#x2F;&#x2F;www.alloyteam.com&#x2F;nav&#x2F;" rel="noopener" target="_blank">Web前端导航</a>
            </li>
            <li class="links-of-blogroll-item">
              <a href="http://www.uisdc.com/" title="http:&#x2F;&#x2F;www.uisdc.com&#x2F;" rel="noopener" target="_blank">优设</a>
            </li>
            <li class="links-of-blogroll-item">
              <a href="http://www.zhangxinxu.com/" title="http:&#x2F;&#x2F;www.zhangxinxu.com&#x2F;" rel="noopener" target="_blank">牛人文档</a>
            </li>
            <li class="links-of-blogroll-item">
              <a href="http://ife.baidu.com/" title="http:&#x2F;&#x2F;ife.baidu.com&#x2F;" rel="noopener" target="_blank">百度前端技术学院</a>
            </li>
            <li class="links-of-blogroll-item">
              <a href="http://wf.uisdc.com/cn/" title="http:&#x2F;&#x2F;wf.uisdc.com&#x2F;cn&#x2F;" rel="noopener" target="_blank">google前端开发基础</a>
            </li>
        </ul>
      </div>
    </div>
  </aside>


    </div>

    <div class="main-inner index posts-expand">

    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://hufanglei.github.io/2020/02/07/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84(4)%20--%20%E6%8A%BD%E8%B1%A1%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="胡方雷">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="个人博客">
      <meta itemprop="description" content="直到这一刻微笑着说话为止，我至少留下了一公升眼泪">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | 个人博客">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2020/02/07/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84(4)%20--%20%E6%8A%BD%E8%B1%A1%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/" class="post-title-link" itemprop="url">数据结构(4) -- 抽象数据类型</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2020-02-07 19:46:51" itemprop="dateCreated datePublished" datetime="2020-02-07T19:46:51+08:00">2020-02-07</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2025-01-24 11:37:59" itemprop="dateModified" datetime="2025-01-24T11:37:59+08:00">2025-01-24</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/" itemprop="url" rel="index"><span itemprop="name">数据结构和算法</span></a>
        </span>
    </span>

  
    <span class="post-meta-break"></span>
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>99</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>1 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <span id="more"></span>

<p>@[toc]</p>
<h1 id="到底什么是数据结构"><a href="#到底什么是数据结构" class="headerlink" title="到底什么是数据结构"></a>到底什么是数据结构</h1><ul>
<li>数据对象在计算机的组织方式</li>
<li>数据对象必定与一系列加载其上的操作相关联</li>
<li>完成这项操作所用的方法就是算法</li>
</ul>
<p><img src="https://raw.githubusercontent.com/hufanglei/img-csdn/main/img/2025-1-13/277921b1b8d7ac811fcc777df7f12a78_1737625574568.png" alt="在这里插入图片描述"></p>
<h1 id="抽象数据类型"><a href="#抽象数据类型" class="headerlink" title="抽象数据类型"></a>抽象数据类型</h1><p><img src="https://raw.githubusercontent.com/hufanglei/img-csdn/main/img/2025-1-13/e228cca5474feb517bd7ddacc868c9ac_1737625574568.png" alt="在这里插入图片描述"></p>
<h2 id="例子-矩阵的抽象数据类型定义"><a href="#例子-矩阵的抽象数据类型定义" class="headerlink" title="例子: 矩阵的抽象数据类型定义"></a>例子: 矩阵的抽象数据类型定义</h2><p>类型名称: 矩阵(Matrix)<br><img src="https://raw.githubusercontent.com/hufanglei/img-csdn/main/img/2025-1-13/85d0df6f539a53aba07c66717bc9e704_1737625574568.png" alt="在这里插入图片描述"><br><img src="https://raw.githubusercontent.com/hufanglei/img-csdn/main/img/2025-1-13/f75f3444df42b01202f74f208cbf7ce8_1737625574568.png" alt="在这里插入图片描述"><br><img src="https://raw.githubusercontent.com/hufanglei/img-csdn/main/img/2025-1-13/c37342273b869b4562e13ad847fb6db9_1737625574568.png" alt="在这里插入图片描述"><br><img src="https://raw.githubusercontent.com/hufanglei/img-csdn/main/img/2025-1-13/57ab5bf3dad741057934d5454e0a0670_1737625590462.png" alt="在这里插入图片描述"></p>
<hr>
<p>完</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://hufanglei.github.io/2020/02/07/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84(3)%20--%20%E5%85%B3%E4%BA%8E%E7%AE%97%E6%B3%95%E6%95%88%E7%8E%87/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="胡方雷">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="个人博客">
      <meta itemprop="description" content="直到这一刻微笑着说话为止，我至少留下了一公升眼泪">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | 个人博客">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2020/02/07/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84(3)%20--%20%E5%85%B3%E4%BA%8E%E7%AE%97%E6%B3%95%E6%95%88%E7%8E%87/" class="post-title-link" itemprop="url">数据结构(3) -- 关于算法效率</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2020-02-07 18:41:59" itemprop="dateCreated datePublished" datetime="2020-02-07T18:41:59+08:00">2020-02-07</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2025-01-24 11:37:59" itemprop="dateModified" datetime="2025-01-24T11:37:59+08:00">2025-01-24</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/" itemprop="url" rel="index"><span itemprop="name">数据结构和算法</span></a>
        </span>
    </span>

  
    <span class="post-meta-break"></span>
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>1.3k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>1 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <span id="more"></span>

<p>@<a href="%E5%85%B3%E4%BA%8E%E7%AE%97%E6%B3%95%E6%95%88%E7%8E%87">TOC</a></p>
<h1 id="例子"><a href="#例子" class="headerlink" title="例子:"></a>例子:</h1><p><img src="https://raw.githubusercontent.com/hufanglei/img-csdn/main/img/2025-1-13/94739aa021e81498e88e29e6560efd15_1737625590462.png" alt="在这里插入图片描述"><br>有2种写法:</p>
<ul>
<li>最容易想到的方法:</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//方式1： 比较low的写法</span></span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">double</span> <span class="title function_">getF1</span><span class="params">(<span class="type">int</span> n, <span class="type">double</span>[] a, <span class="type">double</span> x)</span> &#123;</span><br><span class="line">       <span class="type">int</span> i;</span><br><span class="line">       <span class="type">double</span> <span class="variable">p</span> <span class="operator">=</span> a[<span class="number">0</span>];</span><br><span class="line">       <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">           p += (a[i] * Math.pow(x, i));</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> p;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>秦九韶算法<br><img src="https://raw.githubusercontent.com/hufanglei/img-csdn/main/img/2025-1-13/c6dcc1e246caa6e63d0e5c2389c6cdc5_1737625590462.png" alt="在这里插入图片描述"></li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//方式2： f (x) = a0 + x(a1 + x(…(an-1 + x(an))…))</span></span><br><span class="line"><span class="comment">//秦九韶算法 结合律 从里往外算</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="type">double</span> <span class="title function_">getF2</span><span class="params">(<span class="type">int</span> n, <span class="type">double</span>[] a, <span class="type">double</span> x)</span> &#123;</span><br><span class="line">    <span class="type">int</span> i ;</span><br><span class="line">    <span class="type">double</span> <span class="variable">p</span> <span class="operator">=</span> a[n];</span><br><span class="line">    <span class="keyword">for</span> (i = n; i &gt; <span class="number">0</span>; i--) &#123;</span><br><span class="line">        p = a[i - <span class="number">1</span>] + x * p;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>测试:假设 n&#x3D;9，x&#x3D;1.1，a为10个数字的数组，存储的是0-10:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> <span class="number">9</span>;</span><br><span class="line">        <span class="type">double</span> <span class="variable">x</span> <span class="operator">=</span> <span class="number">1.1</span>;</span><br><span class="line">        <span class="type">double</span>[] a = <span class="keyword">new</span> <span class="title class_">double</span>[<span class="number">10</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt;= n; i++) &#123;</span><br><span class="line">            a[i] = (<span class="type">double</span>) i;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">long</span> <span class="variable">startTime</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">        System.out.println(startTime);</span><br><span class="line">        <span class="type">double</span> <span class="variable">f1</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j=<span class="number">0</span>;j&lt;<span class="number">100000</span>;j++)&#123;</span><br><span class="line">             f1 = getF1(n, a, x);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        System.out.println(f1);</span><br><span class="line">        <span class="type">long</span> <span class="variable">endTime</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">        System.out.println(startTime);</span><br><span class="line">        System.out.println(endTime - startTime);</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;------&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="type">long</span> <span class="variable">startTime2</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">        System.out.println(<span class="string">&quot;startTime2==&quot;</span> + startTime2);</span><br><span class="line">        <span class="type">double</span> <span class="variable">f2</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j=<span class="number">0</span>;j&lt;<span class="number">100000</span>;j++)&#123;</span><br><span class="line">             f2 = getF2(n, a, x);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(f2);</span><br><span class="line">        <span class="type">long</span> <span class="variable">endTime2</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">        System.out.println(endTime2);</span><br><span class="line">        System.out.println(endTime2 - startTime2);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<blockquote>
<p>因为我的是固态硬盘，执行一遍代码看不出来效果，循环执行100000遍，可以看到时间差别,差了一个数量级:<br><img src="https://raw.githubusercontent.com/hufanglei/img-csdn/main/img/2025-1-13/08a89d08dd19dfca0e3247a91138bc6b_1737625590462.png" alt="在这里插入图片描述"></p>
</blockquote>
<hr>
<p>这个例子说明:<br><img src="https://raw.githubusercontent.com/hufanglei/img-csdn/main/img/2025-1-13/9ad6a874e522df1d22e13d90d143bb17_1737625590462.png" alt="在这里插入图片描述"></p>
<hr>
<p>完</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://hufanglei.github.io/2020/02/07/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84(2)%20--%E5%85%B3%E4%BA%8E%E7%A9%BA%E9%97%B4%E4%BD%BF%E7%94%A8/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="胡方雷">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="个人博客">
      <meta itemprop="description" content="直到这一刻微笑着说话为止，我至少留下了一公升眼泪">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | 个人博客">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2020/02/07/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84(2)%20--%E5%85%B3%E4%BA%8E%E7%A9%BA%E9%97%B4%E4%BD%BF%E7%94%A8/" class="post-title-link" itemprop="url">数据结构(2) --关于空间使用</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2020-02-07 16:13:40" itemprop="dateCreated datePublished" datetime="2020-02-07T16:13:40+08:00">2020-02-07</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2025-01-24 11:37:59" itemprop="dateModified" datetime="2025-01-24T11:37:59+08:00">2025-01-24</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/" itemprop="url" rel="index"><span itemprop="name">数据结构和算法</span></a>
        </span>
    </span>

  
    <span class="post-meta-break"></span>
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>898</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>1 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <span id="more"></span>

<p>@<a href="%E5%85%B3%E4%BA%8E%E7%A9%BA%E9%97%B4%E4%BD%BF%E7%94%A8">TOC</a></p>
<h1 id="例子"><a href="#例子" class="headerlink" title="例子:"></a>例子:</h1><p><img src="https://raw.githubusercontent.com/hufanglei/img-csdn/main/img/2025-1-13/861d047568a890d70f4086f1ed4cf6e7_1737625604139.png" alt="在这里插入图片描述"><br>我们实现可以有2种方法:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo1</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> <span class="number">1000</span>;</span><br><span class="line">        <span class="type">long</span> <span class="variable">startTime</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">        System.out.println(startTime);</span><br><span class="line">        getN1(n);</span><br><span class="line">        <span class="type">long</span> <span class="variable">endTime</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">        System.out.println(startTime);</span><br><span class="line">        System.out.println(endTime - startTime);</span><br><span class="line">        System.out.println(<span class="string">&quot;------&quot;</span>);</span><br><span class="line">        <span class="type">long</span> <span class="variable">startTime2</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">        System.out.println(<span class="string">&quot;startTime2==&quot;</span>+startTime2);</span><br><span class="line">        getN2(n);</span><br><span class="line">        <span class="type">long</span> <span class="variable">endTime2</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">        System.out.println(endTime2);</span><br><span class="line">        System.out.println(endTime2 - startTime2);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//方式1： 循环方式打印</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">getN1</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line"></span><br><span class="line">       <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n; i++)&#123;</span><br><span class="line">           System.out.println(i);</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//方式2： 递归</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">getN2</span><span class="params">(<span class="type">int</span> n)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(n &gt; <span class="number">0</span>)&#123;</span><br><span class="line">            getN2(n -<span class="number">1</span>);</span><br><span class="line">            System.out.println(n);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>运行发现：<br><img src="https://raw.githubusercontent.com/hufanglei/img-csdn/main/img/2025-1-13/a8e307ae1e9cd3f2412659b6bda66fc6_1737625604139.png" alt="在这里插入图片描述"><br>这说明，递归虽然代码显得简洁明了，但是计算机不是很喜欢，数字很大的时候，还没来得及打印，计算机的占用空间就爆了。<br>同时，这个例子说明:<br><img src="https://raw.githubusercontent.com/hufanglei/img-csdn/main/img/2025-1-13/0ae3b5af9bc1168e44bf77ab9d216d33_1737625604139.png" alt="在这里插入图片描述"></p>
<hr>
<p>完</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://hufanglei.github.io/2020/02/07/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-(1)%20--%20%E5%85%B3%E4%BA%8E%E6%95%B0%E6%8D%AE%E7%BB%84%E7%BB%87/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="胡方雷">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="个人博客">
      <meta itemprop="description" content="直到这一刻微笑着说话为止，我至少留下了一公升眼泪">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | 个人博客">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2020/02/07/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-(1)%20--%20%E5%85%B3%E4%BA%8E%E6%95%B0%E6%8D%AE%E7%BB%84%E7%BB%87/" class="post-title-link" itemprop="url">数据结构-(1) -- 关于数据组织</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2020-02-07 15:06:50" itemprop="dateCreated datePublished" datetime="2020-02-07T15:06:50+08:00">2020-02-07</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2025-01-24 11:37:59" itemprop="dateModified" datetime="2025-01-24T11:37:59+08:00">2025-01-24</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/" itemprop="url" rel="index"><span itemprop="name">数据结构和算法</span></a>
        </span>
    </span>

  
    <span class="post-meta-break"></span>
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>197</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>1 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <span id="more"></span>

<p>@[TOC]</p>
<h1 id="数据结构官方定义–没有"><a href="#数据结构官方定义–没有" class="headerlink" title="数据结构官方定义–没有"></a>数据结构官方定义–没有</h1><p><img src="https://raw.githubusercontent.com/hufanglei/img-csdn/main/img/2025-1-13/45af8918a537f64c9572f597682caece_1737625604139.png" alt="在这里插入图片描述"></p>
<h1 id="案例-如何在书架上摆放书"><a href="#案例-如何在书架上摆放书" class="headerlink" title="案例:如何在书架上摆放书"></a>案例:如何在书架上摆放书</h1><p>图书的摆放要使得2个相关操作方便实现:</p>
<ul>
<li>操作1：新书怎么插入</li>
<li>操作2: 怎么找到某本指定的书</li>
</ul>
<blockquote>
<p>方法1：随便放</p>
</blockquote>
<ul>
<li>操作1：新书怎么怎么插入?<br> 哪里有空放哪里，一步到位!</li>
<li>操作2: 怎么找到某本指定的书<br>。。。累死</li>
</ul>
<blockquote>
<p>方法2：按照书名的拼音字母顺序摆放</p>
</blockquote>
<ul>
<li>操作1：新书怎么怎么插入?<br>  新进一本《阿Q正传》</li>
<li>操作2: 怎么找到某本指定的书<br> 二分查找!<br><img src="https://raw.githubusercontent.com/hufanglei/img-csdn/main/img/2025-1-13/23d74a38faabcf451f77b385fc8ff8cf_1737625604139.png" alt="在这里插入图片描述"><br><img src="https://raw.githubusercontent.com/hufanglei/img-csdn/main/img/2025-1-13/40f14933b130f62de93fb570f9c1dd68_1737625615624.png" alt="在这里插入图片描述"><br> <img src="https://raw.githubusercontent.com/hufanglei/img-csdn/main/img/2025-1-13/2769f79fd160926a759329d9fc1b4a19_1737625615624.png" alt="在这里插入图片描述"><br> <img src="https://raw.githubusercontent.com/hufanglei/img-csdn/main/img/2025-1-13/d1db888f162593a842b1fa71c816a243_1737625615624.png" alt="在这里插入图片描述"><br>此案例是为了说明一个道理:<br><img src="https://raw.githubusercontent.com/hufanglei/img-csdn/main/img/2025-1-13/1d5ea4d3ccab282859aabf1bd57638bb_1737625615624.png" alt="在这里插入图片描述"></li>
</ul>
<hr>
<p>完</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://hufanglei.github.io/2020/02/06/java%E5%B9%B6%E5%8F%91%E5%8E%9F%E7%90%86%E5%AE%9E%E6%88%98(17)%20--%20%E9%87%8D%E6%8E%92%E5%BA%8F/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="胡方雷">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="个人博客">
      <meta itemprop="description" content="直到这一刻微笑着说话为止，我至少留下了一公升眼泪">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | 个人博客">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2020/02/06/java%E5%B9%B6%E5%8F%91%E5%8E%9F%E7%90%86%E5%AE%9E%E6%88%98(17)%20--%20%E9%87%8D%E6%8E%92%E5%BA%8F/" class="post-title-link" itemprop="url">java并发原理实战(17) -- 重排序</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2020-02-06 19:26:20" itemprop="dateCreated datePublished" datetime="2020-02-06T19:26:20+08:00">2020-02-06</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2025-01-24 11:37:59" itemprop="dateModified" datetime="2025-01-24T11:37:59+08:00">2025-01-24</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/" itemprop="url" rel="index"><span itemprop="name">并发编程</span></a>
        </span>
    </span>

  
    <span class="post-meta-break"></span>
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>7.1k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>6 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <span id="more"></span>

<p>@[TOC]<br>摘自&lt;&lt;java并发编程的艺术&gt;&gt;一书，加深记忆，记录下:</p>
<h1 id="重排序"><a href="#重排序" class="headerlink" title="重排序"></a>重排序</h1><p><img src="https://raw.githubusercontent.com/hufanglei/img-csdn/main/img/2025-1-13/63e1c587cc84dde9749b8b1f687a93d3_1737625615624.png" alt="在这里插入图片描述"></p>
<h2 id="什么是重排序"><a href="#什么是重排序" class="headerlink" title="什么是重排序"></a>什么是重排序</h2><p>重排序是指编译器和处理器为了优化程序性能而对指令序列进行重新排序的一种手段。</p>
<h2 id="数据依赖性"><a href="#数据依赖性" class="headerlink" title="数据依赖性"></a>数据依赖性</h2><p>如果两个操作访问同一个变量，且这两个操作中有一个为写操作，此时这两个操作之间<br>就存在数据依赖性。数据依赖分为下列3种类型，如表3-4所示。<br><img src="https://raw.githubusercontent.com/hufanglei/img-csdn/main/img/2025-1-13/3274fe5f0275a5ed2ad6a40391d98e6c_1737625628060.png" alt="在这里插入图片描述"><br>上面3种情况，只要重排序两个操作的执行顺序，程序的执行结果就会被改变。<br>前面提到过，编译器和处理器可能会对操作做重排序。编译器和处理器在重排序时，会遵守数据依赖性，编译器和处理器不会改变存在数据依赖关系的两个操作的执行顺序。<br>这里所说的数据依赖性仅针对单个处理器中执行的指令序列和单个线程中执行的操作，不同处理器之间和不同线程之间的数据依赖性不被编译器和处理器考虑。</p>
<h2 id="as-if-serial语义"><a href="#as-if-serial语义" class="headerlink" title="as-if-serial语义"></a>as-if-serial语义</h2><p>as-if-serial语义的意思是：不管怎么重排序（编译器和处理器为了提高并行度），（单线程）程序的执行结果不能被改变。编译器、runtime和处理器都必须遵守as-if-serial语义。<br>为了遵守as-if-serial语义，编译器和处理器不会对存在数据依赖关系的操作做重排序，因为这种重排序会改变执行结果。但是，如果操作之间不存在数据依赖关系，这些操作就可能被编译器和处理器重排序。为了具体说明，请看下面计算圆面积的代码示例。<br><img src="https://raw.githubusercontent.com/hufanglei/img-csdn/main/img/2025-1-13/f3796b23eb326efca3cef04548bedf37_1737625628060.png" alt="在这里插入图片描述"><br>如图3-6所示，A和C之间存在数据依赖关系，同时B和C之间也存在数据依赖关系。因此在最终执行的指令序列中，C不能被重排序到A和B的前面（C排到A和B的前面，程序的结果将会被改变）。但A和B之间没有数据依赖关系，编译器和处理器可以重排序A和B之间的执行顺序。<br>图3-7是该程序的两种执行顺序。<br><img src="https://raw.githubusercontent.com/hufanglei/img-csdn/main/img/2025-1-13/30c1ddf7939616e9fb377b007436ca38_1737625628060.png" alt="在这里插入图片描述"></p>
<p>as-if-serial语义把单线程程序保护了起来，遵守as-if-serial语义的编译器、runtime和处理器共同为编写单线程程序的程序员创建了一个幻觉：单线程程序是按程序的顺序来执行的。asif-serial语义使单线程程序员无需担心重排序会干扰他们，也无需担心内存可见性问题。</p>
<h2 id="指令重排序分类"><a href="#指令重排序分类" class="headerlink" title="指令重排序分类"></a>指令重排序分类</h2><p>在执行程序时，为了提高性能，编译器和处理器常常会对指令做重排序。重排序分3种类<br>型。</p>
<ul>
<li><p>1）编译器优化的重排序。编译器在不改变单线程程序语义的前提下，可以重新安排语句的执行顺序。</p>
</li>
<li><p>2）指令级并行的重排序。现代处理器采用了指令级并行技术（Instruction-LevelParallelism，ILP）来将多条指令重叠执行。如果不存在数据依赖性，处理器可以改变语句对应<br>机器指令的执行顺序。</p>
</li>
<li><p>3）内存系统的重排序。由于处理器使用缓存和读&#x2F;写缓冲区，这使得加载和存储操作看上<br>​    去可能是在乱序执行。</p>
<p>从Java源代码到最终实际执行的指令序列，会分别经历下面3种重排序，如图3-3所示</p>
</li>
</ul>
<p><img src="https://raw.githubusercontent.com/hufanglei/img-csdn/main/img/2025-1-13/4077da2e56bd355b14b040a5d22b9d76_1737625628060.png" alt="在这里插入图片描述"><br>  上述的1属于编译器重排序，2和3属于处理器重排序。这些重排序可能会导致多线程程序出现内存可见性问题。对于编译器，JMM的编译器重排序规则会禁止特定类型的编译器重排序（不是所有的编译器重排序都要禁止）。对于处理器重排序，JMM的处理器重排序规则会要求Java编译器在生成指令序列时，插入特定类型的内存屏障（Memory Barriers，Intel称之为Memory Fence）指令，通过内存屏障指令来禁止特定类型的处理器重排序。<br>  JMM属于语言级的内存模型，它确保在不同的编译器和不同的处理器平台之上，通过禁止特定类型的编译器重排序和处理器重排序，为程序员提供一致的内存可见性保证。</p>
<h2 id="重排序会产生什么问题"><a href="#重排序会产生什么问题" class="headerlink" title="重排序会产生什么问题"></a>重排序会产生什么问题</h2><ol>
<li>重排序可能会导致多线程程序出现内存可见性问题。(工作内存和主内存，编译器处理器重排序导致的可见性）</li>
<li>重排序会导致有序性问题，程序的读写顺序于内存的读写顺序不一样（编译器处理器重排序，内存缓冲区(是处理器重排序的内容))</li>
</ol>
<h1 id="happen-before概述"><a href="#happen-before概述" class="headerlink" title="happen-before概述"></a>happen-before概述</h1><p><img src="https://raw.githubusercontent.com/hufanglei/img-csdn/main/img/2025-1-13/8cc56b988c9c940df5e0a8b7d86d21ff_1737625628060.png" alt="在这里插入图片描述"></p>
<p>从JDK 5开始，Java使用新的JSR-133内存模型（除非特别说明，本文针对的都是JSR-133内存模型）。JSR-133使用happens-before的概念来阐述操作之间的内存可见性。在JMM中，如果一个操作执行的结果需要对另一个操作可见，那么这两个操作之间必须要存在happens-before关系。这里提到的两个操作既可以是在一个线程之内，也可以是在不同线程之间。<br>与程序员密切相关的happens-before规则如下。</p>
<h2 id="·1）程序顺序规则："><a href="#·1）程序顺序规则：" class="headerlink" title="·1）程序顺序规则："></a>·1）程序顺序规则：</h2><p>一个线程中的每个操作，happens-before于该线程中的任意后续操作。</p>
<h2 id="·2）监视器锁规则："><a href="#·2）监视器锁规则：" class="headerlink" title="·2）监视器锁规则："></a>·2）监视器锁规则：</h2><p>对一个锁的解锁，happens-before于随后对这个锁的加锁。</p>
<h2 id="·3）volatile变量规则："><a href="#·3）volatile变量规则：" class="headerlink" title="·3）volatile变量规则："></a>·3）volatile变量规则：</h2><p>对一个volatile域的写，happens-before于任意后续对这个volatile域的读。<br><img src="https://raw.githubusercontent.com/hufanglei/img-csdn/main/img/2025-1-13/1350b42a74de414963f26d42f887edd4_1737625640032.png" alt="在这里插入图片描述"><br><img src="https://raw.githubusercontent.com/hufanglei/img-csdn/main/img/2025-1-13/03d32026d8f6786da00437daabf7f969_1737625640032.png" alt="在这里插入图片描述"></p>
<h2 id="·4）传递性："><a href="#·4）传递性：" class="headerlink" title="·4）传递性："></a>·4）传递性：</h2><p>如果A happens-before B，且B happens-before C，那么A happens-before C。</p>
<blockquote>
<p>注意：两个操作之间具有happens-before关系，并不意味着前一个操作必须要在后一个操作之前执行！happens-before仅仅要求前一个操作（执行的结果）对后一个操作可见，且前一个操作按顺序排在第二个操作之前（the first is visible to and ordered before the second）。happens-before的定义很微妙，后文会具体说明happens-before为什么要这么定义。</p>
</blockquote>
<h2 id="5）start-规则："><a href="#5）start-规则：" class="headerlink" title="5）start()规则："></a>5）start()规则：</h2><p>如果线程A执行操作ThreadB.start()（启动线程B），那么A线程的<br>ThreadB.start()操作happens-before于线程B中的任意操作。<br><img src="https://raw.githubusercontent.com/hufanglei/img-csdn/main/img/2025-1-13/764223b235fac95a554cf95451707815_1737625640032.png" alt="在这里插入图片描述"><br><img src="https://raw.githubusercontent.com/hufanglei/img-csdn/main/img/2025-1-13/e407946ff56f61150e0ee5738b7a1b2b_1737625640032.png" alt="在这里插入图片描述"></p>
<h2 id="6）join-规则："><a href="#6）join-规则：" class="headerlink" title="6）join()规则："></a>6）join()规则：</h2><p>如果线程A执行操作ThreadB.join()并成功返回，那么线程B中的任意操作<br>happens-before于线程A从ThreadB.join()操作成功返回。<br><img src="https://raw.githubusercontent.com/hufanglei/img-csdn/main/img/2025-1-13/70e3a1cd45b45e2d5dfd16bbb5dbf5fc_1737625640032.png" alt="在这里插入图片描述"><br><img src="https://raw.githubusercontent.com/hufanglei/img-csdn/main/img/2025-1-13/704534bd97fefec5aa1f8b6d6c2b108f_1737625653572.png" alt="在这里插入图片描述"></p>
<h1 id="锁的内存语义"><a href="#锁的内存语义" class="headerlink" title="锁的内存语义"></a>锁的内存语义</h1><h2 id="1-锁的释放-获取建立的happens-before关系"><a href="#1-锁的释放-获取建立的happens-before关系" class="headerlink" title="1.锁的释放-获取建立的happens-before关系"></a>1.锁的释放-获取建立的happens-before关系</h2><p>锁是Java并发编程中最重要的同步机制。锁除了让临界区互斥执行外，还可以让释放锁的线程向获取同一个锁的线程发送消息。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MonitorExample</span> &#123;</span><br><span class="line">	<span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">writer</span><span class="params">()</span> &#123;　　　　 <span class="comment">// 1</span></span><br><span class="line">		a++;　　　　　　　　　　 <span class="comment">// 2</span></span><br><span class="line">	&#125;　　　　　　　　　　　　 <span class="comment">// 3</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">reader</span><span class="params">()</span> &#123;　　　 <span class="comment">// 4</span></span><br><span class="line">		<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> a;　　　　　　　　 <span class="comment">// 5</span></span><br><span class="line">		……</span><br><span class="line">	&#125;　　　　　　　　　　　　 <span class="comment">// 6</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>假设线程A执行writer()方法，随后线程B执行reader()方法。根据happens-before规则，这个<br>过程包含的happens-before关系可以分为3类。<br>1）根据程序次序规则，1 happens-before 2,2 happens-before 3;4 happens-before 5,5 happens-before 6。<br>2）根据监视器锁规则，3 happens-before 4。<br>3）根据happens-before的传递性，2 happens-before 5。<br><img src="https://raw.githubusercontent.com/hufanglei/img-csdn/main/img/2025-1-13/dc276b3ea4c6c62fd0f10b07641c8bd5_1737625653572.png" alt="在这里插入图片描述"><br>在图3-24中，每一个箭头链接的两个节点，代表了一个happens-before关系。黑色箭头表示程序顺序规则；橙色箭头表示监视器锁规则；蓝色箭头表示组合这些规则后提供的happensbefore保证。<br>图3-24表示在线程A释放了锁之后，随后线程B获取同一个锁。在上图中，2 happens-before 5。因此，线程A在释放锁之前所有可见的共享变量，在线程B获取同一个锁之后，将立刻变得对B线程可见。</p>
<h2 id="2-锁的释放和获取的内存语义"><a href="#2-锁的释放和获取的内存语义" class="headerlink" title="2.锁的释放和获取的内存语义"></a>2.锁的释放和获取的内存语义</h2><p>当线程释放锁时，JMM会把该线程对应的本地内存中的共享变量刷新到主内存中。以上面的MonitorExample程序为例，A线程释放锁后，共享数据的状态示意图如图3-25所示。<br><img src="https://raw.githubusercontent.com/hufanglei/img-csdn/main/img/2025-1-13/aa969c3ccd28c5ba260ac1e3d06e0aec_1737625653572.png" alt="在这里插入图片描述"></p>
<p>当线程获取锁时，JMM会把该线程对应的本地内存置为无效。从而使得被监视器保护的临界区代码必须从主内存中读取共享变量。图3-26是锁获取的状态示意图。</p>
<p><img src="https://raw.githubusercontent.com/hufanglei/img-csdn/main/img/2025-1-13/0f6acbf7ac162ed7c516e7d9cbbf79e2_1737625653572.png" alt="在这里插入图片描述"></p>
<p>对比锁释放-获取的内存语义与volatile写-读的内存语义可以看出：锁释放与volatile写有相同的内存语义；锁获取与volatile读有相同的内存语义。<br>下面对锁释放和锁获取的内存语义做个总结。<br>·线程A释放一个锁，实质上是线程A向接下来将要获取这个锁的某个线程发出了（线程A对共享变量所做修改的）消息。<br>·线程B获取一个锁，实质上是线程B接收了之前某个线程发出的（在释放这个锁之前对共享变量所做修改的）消息。<br>·线程A释放锁，随后线程B获取这个锁，这个过程实质上是线程A通过主内存向线程B发送消息。</p>
<h1 id="volatile内存语义"><a href="#volatile内存语义" class="headerlink" title="volatile内存语义"></a>volatile内存语义</h1><h2 id="1-volatile写-读建立的happens-before关系"><a href="#1-volatile写-读建立的happens-before关系" class="headerlink" title="1.volatile写-读建立的happens-before关系"></a>1.volatile写-读建立的happens-before关系</h2><p>从JSR-133开始（即从JDK5开始），volatile变量的写-读可以实现线程之间的通信。<br>从内存语义的角度来说，volatile的写-读与锁的释放-获取有相同的内存效果：volatile写和锁的释放有相同的内存语义；volatile读与锁的获取有相同的内存语义。<br>请看下面使用volatile变量的示例代码。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">VolatileExample</span> &#123;</span><br><span class="line">	<span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">volatile</span> <span class="type">boolean</span> <span class="variable">flag</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">writer</span><span class="params">()</span> &#123;</span><br><span class="line">		a = <span class="number">1</span>;　　　　　 <span class="comment">// 1</span></span><br><span class="line">		flag = <span class="literal">true</span>;　　　 <span class="comment">// 2</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">reader</span><span class="params">()</span> &#123;</span><br><span class="line">		<span class="keyword">if</span> (flag) &#123;　　　　<span class="comment">// 3</span></span><br><span class="line">		<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> a;　　 <span class="comment">// 4</span></span><br><span class="line">		……</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>假设线程A执行writer()方法之后，线程B执行reader()方法。根据happens-before规则，这个<br>过程建立的happens-before关系可以分为3类：<br>1）根据程序次序规则，1 happens-before 2;3 happens-before 4。<br>2）根据volatile规则，2 happens-before 3。<br>3）根据happens-before的传递性规则，1 happens-before 4。<br>上述happens-before关系的图形化表现形式如下。<br><img src="https://raw.githubusercontent.com/hufanglei/img-csdn/main/img/2025-1-13/244dd5be36a626da8eca3f5fa7e87018_1737625653572.png" alt="在这里插入图片描述"></p>
<p>在上图中，每一个箭头链接的两个节点，代表了一个happens-before关系。黑色箭头表示程序顺序规则；橙色箭头表示volatile规则；蓝色箭头表示组合这些规则后提供的happens-before保证。<br>这里A线程写一个volatile变量后，B线程读同一个volatile变量。A线程在写volatile变量之前所有可见的共享变量，在B线程读同一个volatile变量后，将立即变得对B线程可见。</p>
<h2 id="2-volatile写-读的内存语义"><a href="#2-volatile写-读的内存语义" class="headerlink" title="2.volatile写-读的内存语义"></a>2.volatile写-读的内存语义</h2><p>volatile写的内存语义如下。<br>当写一个volatile变量时，JMM会把该线程对应的本地内存中的共享变量值刷新到主内存。<br>以上面示例程序VolatileExample为例，假设线程A首先执行writer()方法，随后线程B执行reader()方法，初始时两个线程的本地内存中的flag和a都是初始状态。图3-17是线程A执行volatile写后，共享变量的状态示意图。<br><img src="https://raw.githubusercontent.com/hufanglei/img-csdn/main/img/2025-1-13/1a2bbdb08f46dc1e20ffcdf962b4b4ff_1737625666206.png" alt="在这里插入图片描述"><br>如图3-17所示，线程A在写flag变量后，本地内存A中被线程A更新过的两个共享变量的值被刷新到主内存中。此时，本地内存A和主内存中的共享变量的值是一致的。<br>volatile读的内存语义如下。<br>当读一个volatile变量时，JMM会把该线程对应的本地内存置为无效。线程接下来将从主内存中读取共享变量。<br>图3-18为线程B读同一个volatile变量后，共享变量的状态示意图。<br>如图所示，在读flag变量后，本地内存B包含的值已经被置为无效。此时，线程B必须从主内存中读取共享变量。线程B的读取操作将导致本地内存B与主内存中的共享变量的值变成一<br>致。<br>如果我们把volatile写和volatile读两个步骤综合起来看的话，在读线程B读一个volatile变量后，写线程A在写这个volatile变量之前所有可见的共享变量的值都将立即变得对读线程B可见。</p>
<p><strong>下面对volatile写和volatile读的内存语义做个总结。</strong><br>·线程A写一个volatile变量，实质上是线程A向接下来将要读这个volatile变量的某个线程发出了（其对共享变量所做修改的）消息。<br>·线程B读一个volatile变量，实质上是线程B接收了之前某个线程发出的（在写这个volatile变量之前对共享变量所做修改的）消息。<br>·线程A写一个volatile变量，随后线程B读这个volatile变量，这个过程实质上是线程A通过主内存向线程B发送消息。</p>
<h1 id="final内存语义"><a href="#final内存语义" class="headerlink" title="final内存语义"></a>final内存语义</h1><p>与前面介绍的锁和volatile相比，对final域的读和写更像是普通的变量访问。下面将介绍final域的内存语义。</p>
<h2 id="1-final域的重排序规则"><a href="#1-final域的重排序规则" class="headerlink" title="1.final域的重排序规则"></a>1.final域的重排序规则</h2><p>对于final域，编译器和处理器要遵守两个重排序规则。<br>1）在构造函数内对一个final域的写入，与随后把这个被构造对象的引用赋值给一个引用变量，这两个操作之间不能重排序。<br>2）初次读一个包含final域的对象的引用，与随后初次读这个final域，这两个操作之间不能<br>重排序。</p>
<p>下面通过一些示例性的代码来分别说明这两个规则:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FinalExample</span> &#123;</span><br><span class="line">	<span class="type">int</span> i;　　　　　　　　　　 <span class="comment">// 普通变量</span></span><br><span class="line">	<span class="keyword">final</span> <span class="type">int</span> j;　　　　　　　　 <span class="comment">// final变量</span></span><br><span class="line">	<span class="keyword">static</span> FinalExample obj;</span><br><span class="line">	<span class="keyword">public</span> <span class="title function_">FinalExample</span> <span class="params">()</span> &#123;　　 <span class="comment">// 构造函数</span></span><br><span class="line">		i = <span class="number">1</span>;　　　　　　　　 <span class="comment">// 写普通域</span></span><br><span class="line">		j = <span class="number">2</span>;　　　　　　　　 <span class="comment">// 写final域</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">writer</span> <span class="params">()</span> &#123;　 <span class="comment">// 写线程A执行</span></span><br><span class="line">		obj = <span class="keyword">new</span> <span class="title class_">FinalExample</span> ();</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">reader</span> <span class="params">()</span> &#123;　 <span class="comment">// 读线程B执行</span></span><br><span class="line">		<span class="type">FinalExample</span> <span class="variable">object</span> <span class="operator">=</span> obj; <span class="comment">// 读对象引用</span></span><br><span class="line">		<span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> object.i;　　　　　 <span class="comment">// 读普通域</span></span><br><span class="line">		<span class="type">int</span> <span class="variable">b</span> <span class="operator">=</span> object.j;　　　　　 <span class="comment">// 读final域</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里假设一个线程A执行writer()方法，随后另一个线程B执行reader()方法。下面我们通过这两个线程的交互来说明这两个规则.</p>
<h2 id="2-写final域的重排序规则"><a href="#2-写final域的重排序规则" class="headerlink" title="2.写final域的重排序规则"></a>2.写final域的重排序规则</h2><p>写final域的重排序规则禁止把final域的写重排序到构造函数之外。这个规则的实现包含<br>下面2个方面。<br>1）JMM禁止编译器把final域的写重排序到构造函数之外。<br>2）编译器会在final域的写之后，构造函数return之前，插入一个StoreStore屏障。这个屏障禁止处理器把final域的写重排序到构造函数之外。<br>现在让我们分析writer()方法。writer()方法只包含一行代码：finalExample&#x3D;newFinalExample()。这行代码包含两个步骤，如下。<br>1）构造一个FinalExample类型的对象。<br>2）把这个对象的引用赋值给引用变量obj。<br>假设线程B读对象引用与读对象的成员域之间没有重排序（马上会说明为什么需要这个假设），图3-29是一种可能的执行时序。<br>在图3-29中，写普通域的操作被编译器重排序到了构造函数之外，读线程B错误地读取了普通变量i初始化之前的值。而写final域的操作，被写final域的重排序规则“限定”在了构造函数之内，读线程B正确地读取了final变量初始化之后的值。<br>写final域的重排序规则可以确保：在对象引用为任意线程可见之前，对象的final域已经被正确初始化过了，而普通域不具有这个保障。以上图为例，在读线程B“看到”对象引用obj时，很可能obj对象还没有构造完成（对普通域i的写操作被重排序到构造函数外，此时初始值1还没有写入普通域i）。<br><img src="https://raw.githubusercontent.com/hufanglei/img-csdn/main/img/2025-1-13/f813698b0be3a0e3c77a9e3ce643114d_1737625666206.png" alt="在这里插入图片描述"></p>
<p><img src="https://raw.githubusercontent.com/hufanglei/img-csdn/main/img/2025-1-13/31d02c56894a141ef3ac0ce48423632e_1737625666206.png" alt="在这里插入图片描述"></p>
<h2 id="3-读final域的重排序规则"><a href="#3-读final域的重排序规则" class="headerlink" title="3.读final域的重排序规则"></a>3.读final域的重排序规则</h2><p><img src="https://raw.githubusercontent.com/hufanglei/img-csdn/main/img/2025-1-13/b548af6a82402a729d834434a006352b_1737625666206.png" alt="在这里插入图片描述"></p>
<p>读final域的重排序规则是，在一个线程中，初次读对象引用与初次读该对象包含的final域，JMM禁止处理器重排序这两个操作（注意，这个规则仅仅针对处理器）。编译器会在读final域操作的前面插入一个LoadLoad屏障。<br>初次读对象引用与初次读该对象包含的final域，这两个操作之间存在间接依赖关系。由于编译器遵守间接依赖关系，因此编译器不会重排序这两个操作。大多数处理器也会遵守间接依赖，也不会重排序这两个操作。但有少数处理器允许对存在间接依赖关系的操作做重排序<br>（比如alpha处理器），这个规则就是专门用来针对这种处理器的。<br>reader()方法包含3个操作。<br>·初次读引用变量obj。<br>·初次读引用变量obj指向对象的普通域j。<br>·初次读引用变量obj指向对象的final域i。<br>现在假设写线程A没有发生任何重排序，同时程序在不遵守间接依赖的处理器上执行，图3-30所示是一种可能的执行时序。<br><img src="https://raw.githubusercontent.com/hufanglei/img-csdn/main/img/2025-1-13/1f6a7cacecf2f14e0f89408fecfdf67d_1737625666206.png" alt="在这里插入图片描述"></p>
<p>在图3-30中，读对象的普通域的操作被处理器重排序到读对象引用之前。读普通域时，该域还没有被写线程A写入，这是一个错误的读取操作。而读final域的重排序规则会把读对象final域的操作“限定”在读对象引用之后，此时该final域已经被A线程初始化过了，这是一个正确的读取操作。<br>读final域的重排序规则可以确保：在读一个对象的final域之前，一定会先读包含这个final域的对象的引用。在这个示例程序中，如果该引用不为null，那么引用对象的final域一定已经被A线程初始化过了。</p>
<hr>
<p>完</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://hufanglei.github.io/2020/02/05/java%E5%B9%B6%E5%8F%91%E5%8E%9F%E7%90%86%E5%AE%9E%E6%88%98(16)%20--jdk8%E6%96%B0%E5%A2%9E%E8%AF%BB%E5%86%99%E9%94%81%E7%9A%84%E5%8D%87%E7%BA%A7%E2%80%94StampedLock/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="胡方雷">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="个人博客">
      <meta itemprop="description" content="直到这一刻微笑着说话为止，我至少留下了一公升眼泪">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | 个人博客">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2020/02/05/java%E5%B9%B6%E5%8F%91%E5%8E%9F%E7%90%86%E5%AE%9E%E6%88%98(16)%20--jdk8%E6%96%B0%E5%A2%9E%E8%AF%BB%E5%86%99%E9%94%81%E7%9A%84%E5%8D%87%E7%BA%A7%E2%80%94StampedLock/" class="post-title-link" itemprop="url">java并发原理实战(16) --jdk8新增读写锁的升级—StampedLock</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2020-02-05 14:36:45" itemprop="dateCreated datePublished" datetime="2020-02-05T14:36:45+08:00">2020-02-05</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2025-01-24 11:37:59" itemprop="dateModified" datetime="2025-01-24T11:37:59+08:00">2025-01-24</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/" itemprop="url" rel="index"><span itemprop="name">并发编程</span></a>
        </span>
    </span>

  
    <span class="post-meta-break"></span>
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>2.4k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>2 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <span id="more"></span>

<p>@[TOC]<br>转载:<a target="_blank" rel="noopener" href="https://blog.csdn.net/panweiwei1994/article/details/78824505">https://blog.csdn.net/panweiwei1994/article/details/78824505</a><br>StampedLock是JDK1.8新增的一个锁，是对读写锁ReentrantReadWriteLock的改进。前面已经学习了ReentrantReadWriteLock，我们了解到，在共享数据很大，且读操作远多于写操作的情况下，ReentrantReadWriteLock值得一试。但要注意的是，只有当前没有线程持有读锁或者写锁时才能获取到写锁，这可能会导致写线程发生饥饿现象，即读线程太多导致写线程迟迟竞争不到锁而一直处于等待状态。StampedLock可以解决这个问题，解决方法是如果在读的过程中发生了写操作，应该重新读而不是直接阻塞写线程。<br><img src="https://raw.githubusercontent.com/hufanglei/img-csdn/main/img/2025-1-13/43da014ff2c32032d8b8e8bbbaac6b3f_1737625679664.png" alt="在这里插入图片描述"></p>
<h1 id="StampedLock有三种读-写模式：写、读、乐观读。"><a href="#StampedLock有三种读-写模式：写、读、乐观读。" class="headerlink" title="StampedLock有三种读&#x2F;写模式：写、读、乐观读。"></a>StampedLock有三种读&#x2F;写模式：写、读、乐观读。</h1><h2 id="写。独占锁"><a href="#写。独占锁" class="headerlink" title="写。独占锁"></a>写。独占锁</h2><p>只有当前没有线程持有读锁或者写锁时才能获取到该锁。方法writeLock()返回一个可用于unlockWrite(long)释放锁的方法的戳记。tryWriteLock()提供不计时和定时的版本。</p>
<h2 id="读。共享锁"><a href="#读。共享锁" class="headerlink" title="读。共享锁"></a>读。共享锁</h2><p>如果当前没有线程持有写锁即可获取该锁，可以由多个线程获取到该锁。方法readLock()返回可用于unlockRead(long)释放锁的方法的戳记。tryReadLock()也提供不计时和定时的版本。</p>
<h2 id="乐观读。方法tryOptimisticRead"><a href="#乐观读。方法tryOptimisticRead" class="headerlink" title="乐观读。方法tryOptimisticRead()"></a>乐观读。方法tryOptimisticRead()</h2><p>仅当锁定当前未处于写入模式时，方法才会返回非零戳记。返回戳记后，需要调用validate(long stamp)方法验证戳记是否可用。也就是看当调用tryOptimisticRead返回戳记后到到当前时间是否有其他线程持有了写锁，如果有，返回false，否则返回true，这时就可以使用该锁了。</p>
<h2 id="转换"><a href="#转换" class="headerlink" title="转换"></a>转换</h2><p>此类还支持有条件地提供三种模式转换的方法。例如，方法tryConvertToWriteLock(long)试图“升级”模式，如果（1）已经处于书写模式（2）处于阅读模式并且没有其他读取器或者（3）处于乐观模式且锁定可用，则返回有效的写入标记。这些方法的形式旨在帮助减少在基于重试的设计中发生的一些代码膨胀。</p>
<p>StampedLock不是可重入的。</p>
<p>下面是一个StampedLock注释中的例子。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Point</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">double</span> x, y;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">StampedLock</span> <span class="variable">sl</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StampedLock</span>();</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 改变当前坐标。</span></span><br><span class="line"><span class="comment">     * 先获取写锁，然后对point坐标进行修改，最后释放锁。</span></span><br><span class="line"><span class="comment">     * 该锁是排它锁，这保证了其他线程调用move函数时候会被阻塞，直到当前线程显示释放了该锁。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">move</span><span class="params">(<span class="type">double</span> deltaX, <span class="type">double</span> deltaY)</span> &#123; <span class="comment">// an exclusively locked method</span></span><br><span class="line">        <span class="type">long</span> <span class="variable">stamp</span> <span class="operator">=</span> sl.writeLock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            x += deltaX;</span><br><span class="line">            y += deltaY;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            sl.unlockWrite(stamp);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 计算当前坐标到原点的距离</span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="type">double</span> <span class="title function_">distanceFromOrigin</span><span class="params">()</span> &#123; <span class="comment">// A read-only method</span></span><br><span class="line">        <span class="comment">//1.尝试获取乐观读锁，返回stamp</span></span><br><span class="line">        <span class="type">long</span> <span class="variable">stamp</span> <span class="operator">=</span> sl.tryOptimisticRead();</span><br><span class="line">        <span class="comment">//2.拷贝参数到本地方法栈中</span></span><br><span class="line">        <span class="type">double</span> <span class="variable">currentX</span> <span class="operator">=</span> x, currentY = y;</span><br><span class="line">        <span class="comment">//3.验证stamp是否有效</span></span><br><span class="line">        <span class="keyword">if</span> (!sl.validate(stamp)) &#123;</span><br><span class="line">            <span class="comment">//4.如果stamp无效，说明得到stamp后，又有其他线程获得了写锁</span></span><br><span class="line">            <span class="comment">//5.获取读锁</span></span><br><span class="line">            stamp = sl.readLock();</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">//6.其他线程修改了x,y的值，为了数据的一致性，需要再次再次拷贝参数到本地方法栈中</span></span><br><span class="line">                currentX = x;</span><br><span class="line">                currentY = y;</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                <span class="comment">//7.释放读锁</span></span><br><span class="line">                sl.unlockRead(stamp);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//8.使用参数的拷贝来计算当前坐标到原点的距离。无论步骤3中stamp有没有验证成功，参数的拷贝都是当前坐标的值</span></span><br><span class="line">        <span class="keyword">return</span> Math.sqrt(currentX * currentX + currentY * currentY);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 如果当前坐标为原点则移动到指定的位置</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">moveIfAtOrigin</span><span class="params">(<span class="type">double</span> newX, <span class="type">double</span> newY)</span> &#123; <span class="comment">// upgrade</span></span><br><span class="line">        <span class="comment">// 获取读锁，保证其他线程不能获取到写锁</span></span><br><span class="line">        <span class="type">long</span> <span class="variable">stamp</span> <span class="operator">=</span> sl.readLock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//如果当前坐标为原点</span></span><br><span class="line">            <span class="keyword">while</span> (x == <span class="number">0.0</span> &amp;&amp; y == <span class="number">0.0</span>) &#123;</span><br><span class="line">                <span class="comment">//尝试升级成写锁</span></span><br><span class="line">                <span class="type">long</span> <span class="variable">ws</span> <span class="operator">=</span> sl.tryConvertToWriteLock(stamp);</span><br><span class="line">                <span class="comment">//如果升级成功，更新坐标值</span></span><br><span class="line">                <span class="keyword">if</span> (ws != <span class="number">0L</span>) &#123;</span><br><span class="line">                    stamp = ws;</span><br><span class="line">                    x = newX;</span><br><span class="line">                    y = newY;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;<span class="comment">//如果升级成功</span></span><br><span class="line">                    sl.unlockRead(stamp);<span class="comment">//先释放读锁</span></span><br><span class="line">                    stamp = sl.writeLock();<span class="comment">//再获取写锁</span></span><br><span class="line">                    <span class="comment">//循环while中的操作，直到成功更新坐标值</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="comment">//最后释放写锁</span></span><br><span class="line">            sl.unlock(stamp);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<hr>
<p>完</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://hufanglei.github.io/2020/02/05/java%E5%B9%B6%E5%8F%91%E5%8E%9F%E7%90%86%E5%AE%9E%E6%88%98(15%EF%BC%89--%20jdk8%E6%96%B0%E5%A2%9ELongAdder%E5%8E%9F%E5%AD%90%E6%80%A7%E6%93%8D%E4%BD%9C%E7%B1%BB%E5%8E%9F%E7%90%86/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="胡方雷">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="个人博客">
      <meta itemprop="description" content="直到这一刻微笑着说话为止，我至少留下了一公升眼泪">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | 个人博客">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2020/02/05/java%E5%B9%B6%E5%8F%91%E5%8E%9F%E7%90%86%E5%AE%9E%E6%88%98(15%EF%BC%89--%20jdk8%E6%96%B0%E5%A2%9ELongAdder%E5%8E%9F%E5%AD%90%E6%80%A7%E6%93%8D%E4%BD%9C%E7%B1%BB%E5%8E%9F%E7%90%86/" class="post-title-link" itemprop="url">java并发原理实战(15）-- jdk8新增LongAdder原子性操作类原理</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2020-02-05 11:57:39" itemprop="dateCreated datePublished" datetime="2020-02-05T11:57:39+08:00">2020-02-05</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2025-01-24 11:37:59" itemprop="dateModified" datetime="2025-01-24T11:37:59+08:00">2025-01-24</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/" itemprop="url" rel="index"><span itemprop="name">并发编程</span></a>
        </span>
    </span>

  
    <span class="post-meta-break"></span>
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>4k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>4 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <span id="more"></span>

<p>@<a href="LongAdder%E5%8E%9F%E7%90%86">toc</a></p>
<p>转载文章: <a target="_blank" rel="noopener" href="https://www.cnblogs.com/huangjuncong/p/9152510.html">https://www.cnblogs.com/huangjuncong/p/9152510.html</a></p>
<h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>LongAdder类是JDK1.8新增的一个原子性操作类。AtomicLong通过CAS算法提供了非阻塞的原子性操作，相比受用阻塞算法的同步器来说性能已经很好了，但是JDK开发组并不满足于此，因为非常搞并发的请求下AtomicLong的性能是不能让人接受的。</p>
<p>如下AtomicLong 的incrementAndGet的代码，虽然AtomicLong使用CAS算法，但是CAS失败后还是通过无限循环的自旋锁不多的尝试，这就是高并发下CAS性能低下的原因所在。源码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="type">long</span> <span class="title function_">incrementAndGet</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            <span class="type">long</span> <span class="variable">current</span> <span class="operator">=</span> get();</span><br><span class="line">            <span class="type">long</span> <span class="variable">next</span> <span class="operator">=</span> current + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span> (compareAndSet(current, next))</span><br><span class="line">                <span class="keyword">return</span> next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>在高并发下N多线程同时去操作一个变量会造成大量线程CAS失败，然后处于自旋状态，这样导致大大浪费CPU资源，降低了并发性。</p>
<p>既然AtomicLong性能问题是由于过多线程同时去竞争同一个变量的更新而降低的，那么如果把一个变量分解为多个变量，让同样多的线程去竞争多个资源，那么性能问题不久迎刃而解了吗？</p>
<p>没错，因此，JDK8 提供的LongAdder就是这个思路。下面通过图形来标示两者的不同，如下图：<br><img src="https://raw.githubusercontent.com/hufanglei/img-csdn/main/img/2025-1-13/4bdfd19e0ff385afdcae926b567c3e5e_1737625679664.png" alt="在这里插入图片描述"></p>
<p>如上图 AtomicLong 是多个线程同时竞争同一个变量情景。</p>
<p> <img src="https://raw.githubusercontent.com/hufanglei/img-csdn/main/img/2025-1-13/2b52e76bfcce2a8479ba98668b69d783_1737625679664.png" alt="在这里插入图片描述"></p>
<p>如上图所示，LongAdder则是内部维护多个Cell变量，每个Cell里面有一个初始值为0的long型变量，在同等并发量的情况下，争夺单个变量的线程会减少，这是变相的减少了争夺共享资源的并发量，另外多个线程在争夺同一个原子变量时候，</p>
<p>如果失败并不是自旋CAS重试，而是尝试获取其他原子变量的锁，最后当获取当前值时候是把所有变量的值累加后再加上base的值返回的。</p>
<p>LongAdder维护了要给延迟初始化的原子性更新数组和一个基值变量base数组的大小保持是2的N次方大小，数组表的下标使用每个线程的hashcode值的掩码表示，数组里面的变量实体是Cell类型。</p>
<p>Cell 类型是Atomic的一个改进，用来减少缓存的争用，对于大多数原子操作字节填充是浪费的，因为原子操作都是无规律的分散在内存中进行的，多个原子性操作彼此之间是没有接触的，但是原子性数组元素彼此相邻存放将能经常共享缓存行，也就是伪共享。所以这在性能上是一个提升。</p>
<p>另外由于Cells占用内存是相对比较大的，所以一开始并不创建，而是在需要时候再创建，也就是惰性加载，当一开始没有空间时候，所有的更新都是操作base变量。</p>
<h2 id="接下来进行LongAdder代码简单分析"><a href="#接下来进行LongAdder代码简单分析" class="headerlink" title="接下来进行LongAdder代码简单分析"></a>接下来进行LongAdder代码简单分析</h2><p>这里我只是简单的介绍一下代码的实现，详细实现，大家可以翻看代码去研究。为了降低高并发下多线程对一个变量CAS争夺失败后大量线程会自旋而造成降低并发性能问题，LongAdder内部通过根据并发请求量来维护多个Cell元素(一个动态的Cell数组)来分担对单个变量进行争夺资源。</p>
<p>首先我们先看LongAdder的构造类图，如下图：</p>
<p><img src="https://raw.githubusercontent.com/hufanglei/img-csdn/main/img/2025-1-13/8dc69e19592746a479ac19c956c32f8f_1737625679664.png" alt="在这里插入图片描述"></p>
<p> 可以看到LongAdder继承自Striped64类，Striped64内部维护着三个变量，LongAdder的真实值其实就是base的值与Cell数组里面所有Cell元素值的累加，base是个基础值，默认是0，cellBusy用来实现自旋锁，当创建Cell元素或者扩容Cell数组时候用来进行线程间的同步。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@sun</span>.misc.Contended <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">Cell</span> &#123;</span><br><span class="line">        <span class="keyword">volatile</span> <span class="type">long</span> value;</span><br><span class="line">        Cell(<span class="type">long</span> x) &#123; value = x; &#125;</span><br><span class="line">        <span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">cas</span><span class="params">(<span class="type">long</span> cmp, <span class="type">long</span> val)</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> UNSAFE.compareAndSwapLong(<span class="built_in">this</span>, valueOffset, cmp, val);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Unsafe 技术</span></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> sun.misc.Unsafe UNSAFE;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">long</span> valueOffset;</span><br><span class="line">        <span class="keyword">static</span> &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                UNSAFE = sun.misc.Unsafe.getUnsafe();</span><br><span class="line">                Class&lt;?&gt; ak = Cell.class;</span><br><span class="line">                valueOffset = UNSAFE.objectFieldOffset</span><br><span class="line">                    (ak.getDeclaredField(<span class="string">&quot;value&quot;</span>));</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(e);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>正如上面的代码可以知道Cell的构造很简单，内部维护一个声明volatile的变量，这里声明为volatile是因为线程操作value变量时候没有使用锁，为了保证变量的内存可见性这里只有声明为volatile。另外这里就是先前文件所说的使用Unsafe类的方法来设置value的值</p>
<p>接下来进入LongAdder的源码里面去看几个重要的方法，如下：</p>
<p>　　- 1.long sum() 方法：<br>　　返回当前的值，内部操作是累加所有 Cell 内部的 value 的值后累加 base，如下代码，由于计算总和时候没有对 Cell 数组进行加锁，所以在累加过程中可能有其它线程对 Cell 中的值进行了修改，也有可能数组进行了扩容，所以 sum 返回的值并不是非常精确的，</p>
<p>返回值并不是一个调用 sum 方法时候的一个原子快照值。</p>
<p>　　源码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">long</span> <span class="title function_">sum</span><span class="params">()</span> &#123;</span><br><span class="line">        Cell[] as = cells; Cell a;</span><br><span class="line">        <span class="type">long</span> <span class="variable">sum</span> <span class="operator">=</span> base;</span><br><span class="line">        <span class="keyword">if</span> (as != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; as.length; ++i) &#123;</span><br><span class="line">                <span class="keyword">if</span> ((a = as[i]) != <span class="literal">null</span>)</span><br><span class="line">                    sum += a.value;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>　　2.void reset() 方法：重置操作，如下代码把 base 置为 0，如果 Cell 数组有元素，则元素值重置为 0。源码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">　　<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">reset</span><span class="params">()</span> &#123;</span><br><span class="line">     Cell[] as = cells; Cell a;</span><br><span class="line">     base = <span class="number">0L</span>;</span><br><span class="line">     <span class="keyword">if</span> (as != <span class="literal">null</span>) &#123;</span><br><span class="line">         <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; as.length; ++i) &#123;</span><br><span class="line">             <span class="keyword">if</span> ((a = as[i]) != <span class="literal">null</span>)</span><br><span class="line">                 a.value = <span class="number">0L</span>;</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>　　</p>
<p>　　3.long sumThenReset() 方法：是sum 的改造版本，如下代码，在计算 sum 累加对应的 cell 值后，把当前 cell 的值重置为 0，base 重置为 0。 当多线程调用该方法时候会有问题，比如考虑第一个调用线程会清空 Cell 的值，后一个线程调用时候累加时候累加的都是 0 值。</p>
<p>　　源码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">　<span class="keyword">public</span> <span class="type">long</span> <span class="title function_">sumThenReset</span><span class="params">()</span> &#123;</span><br><span class="line">    Cell[] as = cells; Cell a;</span><br><span class="line">    <span class="type">long</span> <span class="variable">sum</span> <span class="operator">=</span> base;</span><br><span class="line">    base = <span class="number">0L</span>;</span><br><span class="line">    <span class="keyword">if</span> (as != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; as.length; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> ((a = as[i]) != <span class="literal">null</span>) &#123;</span><br><span class="line">                sum += a.value;</span><br><span class="line">                a.value = <span class="number">0L</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>　</p>
<p>4.long longValue() 等价于 sum()，源码如下：</p>
<p>　</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="type">long</span> <span class="title function_">longValue</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>.sum();</span><br><span class="line">&#125;</span><br><span class="line"> </span><br></pre></td></tr></table></figure>

<p>　</p>
<p>　　5.void add(long x） 累加增量 x 到原子变量，这个过程是原子性的。源码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">　　<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">add</span><span class="params">(<span class="type">long</span> x)</span> &#123;</span><br><span class="line">    Cell[] as; <span class="type">long</span> b, v; <span class="type">int</span> m; Cell a;</span><br><span class="line">    <span class="keyword">if</span> ((as = cells) != <span class="literal">null</span> || !casBase(b = base, b + x)) &#123;<span class="comment">//(1)</span></span><br><span class="line">        <span class="type">boolean</span> <span class="variable">uncontended</span> <span class="operator">=</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">if</span> (as == <span class="literal">null</span> || (m = as.length - <span class="number">1</span>) &lt; <span class="number">0</span> ||<span class="comment">//(2)</span></span><br><span class="line">            (a = as[getProbe() &amp; m]) == <span class="literal">null</span> ||<span class="comment">//(3)</span></span><br><span class="line">            !(uncontended = a.cas(v = a.value, v + x)))<span class="comment">//(4)</span></span><br><span class="line">            longAccumulate(x, <span class="literal">null</span>, uncontended);<span class="comment">//(5)</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">casBase</span><span class="params">(<span class="type">long</span> cmp, <span class="type">long</span> val)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> UNSAFE.compareAndSwapLong(<span class="built_in">this</span>, BASE, cmp, val);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>可以看到上面代码，当第一个线程A执行add时候，代码（1）会执行casBase方法，通过CAS设置base为 X， 如果成功则直接返回，这时候base的值为1。</p>
<p>假如多个线程同时执行add时候，同时执行到casBase则只有一个线程A成功返回，其他线程由于CAS失败执行代码（2），代码（2）是获取cells数组的长度，如果数组长度为0，则执行代码（5），否则cells长度不为0，说明cells数组有元素则执行代码（3），</p>
<p>代码（3）首先计算当前线程在数组中下标，然后获取当前线程对应的cell值，如果获取到则执行（4）进行CAS操作，CAS失败则执行代码（5）。</p>
<p>代码（5）里面是具体进行数组扩充和初始化，这个代码比较复杂，这里就不讲解了，有兴趣的可以进去看看。</p>
<hr>
<p>完</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://hufanglei.github.io/2020/02/04/java%E5%B9%B6%E5%8F%91%E5%8E%9F%E7%90%86%E5%AE%9E%E6%88%98(14)--%E8%87%AA%E5%B7%B1%E5%AE%9E%E7%8E%B0%E7%AE%80%E6%98%93web%E6%9C%8D%E5%8A%A1%E5%99%A8/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="胡方雷">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="个人博客">
      <meta itemprop="description" content="直到这一刻微笑着说话为止，我至少留下了一公升眼泪">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | 个人博客">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2020/02/04/java%E5%B9%B6%E5%8F%91%E5%8E%9F%E7%90%86%E5%AE%9E%E6%88%98(14)--%E8%87%AA%E5%B7%B1%E5%AE%9E%E7%8E%B0%E7%AE%80%E6%98%93web%E6%9C%8D%E5%8A%A1%E5%99%A8/" class="post-title-link" itemprop="url">java并发原理实战(14)--自己实现简易web服务器</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2020-02-04 21:17:22" itemprop="dateCreated datePublished" datetime="2020-02-04T21:17:22+08:00">2020-02-04</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2025-01-24 11:37:59" itemprop="dateModified" datetime="2025-01-24T11:37:59+08:00">2025-01-24</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/" itemprop="url" rel="index"><span itemprop="name">并发编程</span></a>
        </span>
    </span>

  
    <span class="post-meta-break"></span>
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>9.8k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>9 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <span id="more"></span>

<p>@<a href="%E7%AE%80%E6%98%93web%E6%9C%8D%E5%8A%A1%E5%99%A8">toc</a></p>
<h1 id="0-web服务器知识储备"><a href="#0-web服务器知识储备" class="headerlink" title="0.web服务器知识储备"></a>0.web服务器知识储备</h1><p>web服务器知识储备，了解网络编程，其实就是java的socket。如果实现网络请求，也就是服务端能够接收客户端的请求，然后服务端再对客户端进行响应。响应的话需要按照http的请求格式，浏览器才能识别显示。<br><a target="_blank" rel="noopener" href="https://www.cnblogs.com/breka/articles/9791664.html">http的格式推荐文章</a><br>HTTP的请求包括：请求行(request line)、请求头部(header)、空行 和 请求数据 四个部分组成。</p>
<p>Http请求消息结构<br>抓包的request结构如下：</p>
<blockquote>
<p>GET &#x2F;mix&#x2F;76.html?name&#x3D;kelvin&amp;password&#x3D;123456 HTTP&#x2F;1.1<br>Host: <a target="_blank" rel="noopener" href="http://www.fishbay.cn/">www.fishbay.cn</a><br>Upgrade-Insecure-Requests: 1<br>User-Agent: Mozilla&#x2F;5.0 (Macintosh; Intel Mac OS X 10_11_5) AppleWebKit&#x2F;537.36 (KHTML, like Gecko) Chrome&#x2F;56.0.2924.87 Safari&#x2F;537.36<br>Accept: text&#x2F;html,application&#x2F;xhtml+xml,application&#x2F;xml;q&#x3D;0.9,image&#x2F;webp,<em>&#x2F;</em>;q&#x3D;0.8<br>Accept-Encoding: gzip, deflate, sdch<br>Accept-Language: zh-CN,zh;q&#x3D;0.8,en;q&#x3D;0.6<br>1.请求行<br>GET为请求类型，&#x2F;mix&#x2F;76.html?name&#x3D;kelvin&amp;password&#x3D;123456为要访问的资源，HTTP&#x2F;1.1是协议版本<br>2.请求头部<br>从第二行起为请求头部，Host指出请求的目的地（主机域名）；User-Agent是客户端的信息，它是检测浏览器类型的重要信息，由浏览器定义，并且在每个请求中自动发送。<br>3.空行<br>请求头后面必须有一个空行<br>4.请求数据<br>请求的数据也叫请求体，可以添加任意的其它数据。这个例子的请求体为空<br>Response<br>一般情况下，服务器收到客户端的请求后，就会有一个HTTP的响应消息，HTTP响应也由4部分组成，分别是：状态行、响应头、空行 和 响应体。</p>
</blockquote>
<p><img src="https://raw.githubusercontent.com/hufanglei/img-csdn/main/img/2025-1-13/d154b236d802a1dfcbc6e418b1bc2057_1737625679664.png" alt="在这里插入图片描述"></p>
<h1 id="1-简易web服务器-版本1"><a href="#1-简易web服务器-版本1" class="headerlink" title="1.简易web服务器-版本1"></a>1.简易web服务器-版本1</h1><p>之前的javaweb项目中，一般把项目放在tomcat的webapps目录或者直接放在ROOT根目录下，我们在浏览器输入<code>服务器的地址和tomcat的端口号等信息</code>就可以访问到服务器上的资源了。<br>现在我们要实现类似tomcat的web服务器功能：</p>
<blockquote>
<p>假设我们本地就是服务器，现在就实现在浏览器输入个地址，访问到本地的某个盘符的资源的功能：</p>
</blockquote>
<ul>
<li>首先<br>在e盘建个webroot目录，我们的资源都放在这个目录下。<br>在这个文件下写个index.html:</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">	&lt;meta charset=<span class="string">&quot;utf-8&quot;</span>&gt;</span><br><span class="line">	&lt;title&gt;index.html&lt;/title&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">	hello world</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure>
<ul>
<li>写web服务端代码:</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"><span class="keyword">import</span> java.net.ServerSocket;</span><br><span class="line"><span class="keyword">import</span> java.net.Socket;</span><br><span class="line"><span class="keyword">import</span> java.util.Date;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HttpServer</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="comment">//启动服务器，监听8888端口</span></span><br><span class="line">        <span class="type">ServerSocket</span> <span class="variable">server</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ServerSocket</span>(<span class="number">8888</span>);</span><br><span class="line">        <span class="keyword">while</span> (!Thread.interrupted()) &#123;</span><br><span class="line">            <span class="comment">//不停的接收客户端请求</span></span><br><span class="line">            <span class="type">Socket</span> <span class="variable">client</span> <span class="operator">=</span> server.accept();</span><br><span class="line">            <span class="comment">//获取输入流</span></span><br><span class="line">            <span class="type">InputStream</span> <span class="variable">ins</span> <span class="operator">=</span> client.getInputStream();</span><br><span class="line">            <span class="type">OutputStream</span> <span class="variable">out</span> <span class="operator">=</span> client.getOutputStream();</span><br><span class="line"><span class="comment">//            int len = 0;</span></span><br><span class="line"><span class="comment">//            byte[] b = new byte[1024];</span></span><br><span class="line"><span class="comment">//            while ((len = ins.read(b)) != -1) &#123;</span></span><br><span class="line"><span class="comment">//                System.out.println(new String(b, 0, len));</span></span><br><span class="line"><span class="comment">//            &#125;</span></span><br><span class="line">            <span class="type">BufferedReader</span> <span class="variable">reader</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedReader</span>(<span class="keyword">new</span> <span class="title class_">InputStreamReader</span>(client.getInputStream()));</span><br><span class="line">            <span class="type">String</span> <span class="variable">line</span> <span class="operator">=</span> reader.readLine();</span><br><span class="line">            System.out.println(line);</span><br><span class="line"></span><br><span class="line">            <span class="comment">//给用户(客户端)响应</span></span><br><span class="line">            <span class="type">FileInputStream</span> <span class="variable">i</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;e:\\webroot\\index.html&quot;</span>);</span><br><span class="line">            <span class="type">PrintWriter</span> <span class="variable">pw</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">PrintWriter</span>(out);</span><br><span class="line">            <span class="type">BufferedReader</span> <span class="variable">fr</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedReader</span>(<span class="keyword">new</span> <span class="title class_">InputStreamReader</span>(i, <span class="string">&quot;UTF-8&quot;</span>));</span><br><span class="line">            <span class="type">String</span> <span class="variable">c</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">            pw.println(<span class="string">&quot;HTTP/1.1 200 OK&quot;</span>);</span><br><span class="line">            pw.println(<span class="string">&quot;Content-Type: text/html;charset=utf-8&quot;</span>);</span><br><span class="line">            pw.println(<span class="string">&quot;Content-Length: &quot;</span> + i.available());</span><br><span class="line">            pw.println(<span class="string">&quot;Server: hello&quot;</span>);</span><br><span class="line">            pw.println(<span class="string">&quot;Date: &quot;</span> + <span class="keyword">new</span> <span class="title class_">Date</span>());</span><br><span class="line">            pw.println(<span class="string">&quot;&quot;</span>);</span><br><span class="line">            pw.flush();</span><br><span class="line">            <span class="keyword">while</span> ((c = fr.readLine()) != <span class="literal">null</span>) &#123;</span><br><span class="line">                pw.println(c);</span><br><span class="line">            &#125;</span><br><span class="line">            pw.flush();</span><br><span class="line">            fr.close();</span><br><span class="line">            pw.close();</span><br><span class="line">            reader.close();</span><br><span class="line">            client.close();</span><br><span class="line">        &#125;</span><br><span class="line">        server.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>关键的代码：需要按照http格式响应，客户端才能识别。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">pw.println(<span class="string">&quot;HTTP/1.1 200 OK&quot;</span>);</span><br><span class="line">pw.println(<span class="string">&quot;Content-Type: text/html;charset=utf-8&quot;</span>);</span><br><span class="line">pw.println(<span class="string">&quot;Content-Length: &quot;</span> + i.available());</span><br><span class="line">pw.println(<span class="string">&quot;Server: hello&quot;</span>);</span><br><span class="line">pw.println(<span class="string">&quot;Date: &quot;</span> + <span class="keyword">new</span> <span class="title class_">Date</span>());</span><br><span class="line">pw.println(<span class="string">&quot;&quot;</span>);</span><br><span class="line">pw.flush();</span><br></pre></td></tr></table></figure>

<ul>
<li>运行代码，这样我们就在服务端开放了8888端口，客户端请求去就可以了</li>
<li>在浏览器输入 <a target="_blank" rel="noopener" href="http://localhost:8888/">http://localhost:8888/</a> 查看能否访问到index.html<br><img src="https://raw.githubusercontent.com/hufanglei/img-csdn/main/img/2025-1-13/edd03439b4fc779deadf678a121a5fa7_1737625693898.png" alt="在这里插入图片描述"><br>结果: 我们访问到了本地的index.html资源。</li>
</ul>
<blockquote>
<p>但是这里有个问题，只能请求一次，所以我们要进行优化，变成多线程版本。</p>
</blockquote>
<h1 id="2-简易web服务器版本2-多线程版"><a href="#2-简易web服务器版本2-多线程版" class="headerlink" title="2.简易web服务器版本2-多线程版"></a>2.简易web服务器版本2-多线程版</h1><p>这里我们修改服务器端的代码</p>
<ul>
<li>抽出一个单独响应客户端的线程类</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line">mport java.io.*;</span><br><span class="line"><span class="keyword">import</span> java.net.Socket;</span><br><span class="line"><span class="keyword">import</span> java.util.Date;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ServerThread</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> Socket client;</span><br><span class="line">    <span class="keyword">private</span> InputStream ins;</span><br><span class="line">    <span class="keyword">private</span> OutputStream out;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> PrintWriter pw;</span><br><span class="line">    <span class="keyword">private</span> BufferedReader br;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">init</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            ins = client.getInputStream();</span><br><span class="line">            out = client.getOutputStream();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">ServerThread</span><span class="params">(Socket client)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.client = client;</span><br><span class="line">        init();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            go();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">go</span><span class="params">()</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="type">BufferedReader</span> <span class="variable">reader</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedReader</span>(<span class="keyword">new</span> <span class="title class_">InputStreamReader</span>(ins));</span><br><span class="line">        <span class="type">String</span> <span class="variable">line</span> <span class="operator">=</span> reader.readLine();</span><br><span class="line">        System.out.println(line);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//给用户响应</span></span><br><span class="line">        <span class="type">FileInputStream</span> <span class="variable">i</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;e:\\webroot\\index.html&quot;</span>);</span><br><span class="line">        <span class="type">PrintWriter</span> <span class="variable">pw</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">PrintWriter</span>(out);</span><br><span class="line">        <span class="type">BufferedReader</span> <span class="variable">fr</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedReader</span>(<span class="keyword">new</span> <span class="title class_">InputStreamReader</span>(i, <span class="string">&quot;UTF-8&quot;</span>));</span><br><span class="line">        <span class="type">String</span> <span class="variable">c</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        pw.println(<span class="string">&quot;HTTP/1.1 200 OK&quot;</span>);</span><br><span class="line">        pw.println(<span class="string">&quot;Content-Type: text/html;charset=utf-8&quot;</span>);</span><br><span class="line">        pw.println(<span class="string">&quot;Content-Length: &quot;</span> + i.available());</span><br><span class="line">        pw.println(<span class="string">&quot;Server: hello&quot;</span>);</span><br><span class="line">        pw.println(<span class="string">&quot;Date: &quot;</span> + <span class="keyword">new</span> <span class="title class_">Date</span>());</span><br><span class="line">        pw.println(<span class="string">&quot;&quot;</span>);</span><br><span class="line">        pw.flush();</span><br><span class="line">        <span class="keyword">while</span> ((c = fr.readLine()) != <span class="literal">null</span>) &#123;</span><br><span class="line">            pw.println(c);</span><br><span class="line">        &#125;</span><br><span class="line">        pw.flush();</span><br><span class="line">        fr.close();</span><br><span class="line">        pw.close();</span><br><span class="line">        reader.close();</span><br><span class="line">        client.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<ul>
<li>服务端的主类</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"><span class="keyword">import</span> java.net.ServerSocket;</span><br><span class="line"><span class="keyword">import</span> java.net.Socket;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HttpServer2</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="comment">//启动服务器，监听8888端口</span></span><br><span class="line">        <span class="type">ServerSocket</span> <span class="variable">server</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ServerSocket</span>(<span class="number">8888</span>);</span><br><span class="line">        <span class="keyword">while</span> (!Thread.interrupted()) &#123;</span><br><span class="line">            <span class="comment">//不停的接收客户端请求</span></span><br><span class="line">            <span class="type">Socket</span> <span class="variable">client</span> <span class="operator">=</span> server.accept();</span><br><span class="line">             <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">ServerThread</span>(client)).start();</span><br><span class="line">        &#125;</span><br><span class="line">        server.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这样多线程版已完成，测试<br>打开多个浏览器窗口,都可以访问到index.html的资源：<br><img src="https://raw.githubusercontent.com/hufanglei/img-csdn/main/img/2025-1-13/588c97a74e9ac62cfe4e164079bfa0cf_1737625693898.png" alt="在这里插入图片描述"></p>
<h1 id="3-1简易web服务器版本3-访问图片资源"><a href="#3-1简易web服务器版本3-访问图片资源" class="headerlink" title="3.1简易web服务器版本3-访问图片资源"></a>3.1简易web服务器版本3-访问图片资源</h1><p>上面的index.html资源中，只有文字，如果我们修改下</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;utf-8&quot;</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">title</span>&gt;</span>index.html<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">	hello world</span><br><span class="line">	<span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;1.jpg&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p><img src="https://raw.githubusercontent.com/hufanglei/img-csdn/main/img/2025-1-13/d7137e5c9755d7276aea688cc465a563_1737625693898.png" alt="在这里插入图片描述"><br>1.jpg图片如下:<br><img src="https://raw.githubusercontent.com/hufanglei/img-csdn/main/img/2025-1-13/564b97bab94b6b967092fffeed540cb5_1737625693898.png" alt="在这里插入图片描述"><br>现在修改代码，能够访问到图片，这样我们不能通过</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">PrintWriter</span> <span class="variable">pw</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">PrintWriter</span>(out);</span><br><span class="line"><span class="keyword">while</span> ((c = fr.readLine()) != <span class="literal">null</span>) &#123;</span><br><span class="line">           pw.println(c);</span><br><span class="line">       &#125;</span><br></pre></td></tr></table></figure>
<p>这段代码了，因为，这个只能读取文本，我们只能使用inputstream来读取二进制。同时，响应的时候content-type的响应头也不能固定为text&#x2F;html了，要根据请求的资源动态修改，比如jpg的图片，后缀就应该是image&#x2F;jpeg。<br>我们可以定义个缓存map进行动态赋值。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> Map&lt;String, String&gt; contentMap = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">   <span class="keyword">static</span> &#123;</span><br><span class="line">       contentMap.put(<span class="string">&quot;html&quot;</span>, <span class="string">&quot;text/html;charset=utf-8&quot;</span>);</span><br><span class="line">       contentMap.put(<span class="string">&quot;jpg&quot;</span>, <span class="string">&quot;image/jpeg&quot;</span>);</span><br><span class="line"></span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<p>浏览器访问的时候，可以看到打印的line为:<br><img src="https://raw.githubusercontent.com/hufanglei/img-csdn/main/img/2025-1-13/d16514e5eef33e759c5ca8fe96103867_1737625693898.png" alt="在这里插入图片描述"><br>这其实就是http请求格式的第一行:<br><img src="https://raw.githubusercontent.com/hufanglei/img-csdn/main/img/2025-1-13/c745247dae3c357775e71e1f2329300d_1737625704602.png" alt="在这里插入图片描述"><br>我们用空格分割，索引为1的就是资源，我们可以得到资源的后缀，给content-type动态赋值，如果直接就是\。我们可以手动改成index.html：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">BufferedReader</span> <span class="variable">reader</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedReader</span>(<span class="keyword">new</span> <span class="title class_">InputStreamReader</span>(ins));</span><br><span class="line">       <span class="type">String</span> <span class="variable">line</span> <span class="operator">=</span> reader.readLine().split(<span class="string">&quot; &quot;</span>)[<span class="number">1</span>].replace(<span class="string">&quot;/&quot;</span>,<span class="string">&quot;\\&quot;</span>);</span><br><span class="line">       <span class="keyword">if</span> (line.equals(<span class="string">&quot;\\&quot;</span>))&#123;</span><br><span class="line">           line += <span class="string">&quot;index.html&quot;</span>;</span><br><span class="line">       &#125;</span><br><span class="line">       System.out.println(line);</span><br></pre></td></tr></table></figure>
<ul>
<li>现在全部的修改如下<br>HttpServer2类代码不变，修改ServerThread</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ServerThread</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">webroot</span> <span class="operator">=</span> <span class="string">&quot;e:\\webroot\\&quot;</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Map&lt;String, String&gt; contentMap = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        contentMap.put(<span class="string">&quot;html&quot;</span>, <span class="string">&quot;text/html;charset=utf-8&quot;</span>);</span><br><span class="line">        contentMap.put(<span class="string">&quot;jpg&quot;</span>, <span class="string">&quot;image/jpeg&quot;</span>);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> Socket client;</span><br><span class="line">    <span class="keyword">private</span> InputStream ins;</span><br><span class="line">    <span class="keyword">private</span> OutputStream out;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> PrintWriter pw;</span><br><span class="line">    <span class="keyword">private</span> BufferedReader br;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">init</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            ins = client.getInputStream();</span><br><span class="line">            out = client.getOutputStream();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">ServerThread</span><span class="params">(Socket client)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.client = client;</span><br><span class="line">        init();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            go();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">go</span><span class="params">()</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="type">BufferedReader</span> <span class="variable">reader</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedReader</span>(<span class="keyword">new</span> <span class="title class_">InputStreamReader</span>(ins));</span><br><span class="line">        <span class="type">String</span> <span class="variable">line</span> <span class="operator">=</span> reader.readLine().split(<span class="string">&quot; &quot;</span>)[<span class="number">1</span>].replace(<span class="string">&quot;/&quot;</span>,<span class="string">&quot;\\&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span> (line.equals(<span class="string">&quot;\\&quot;</span>))&#123;</span><br><span class="line">            line += <span class="string">&quot;index.html&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(line);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//给用户响应</span></span><br><span class="line">        <span class="type">PrintWriter</span> <span class="variable">pw</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">PrintWriter</span>(out);</span><br><span class="line">        <span class="type">FileInputStream</span> <span class="variable">i</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(webroot + line);</span><br><span class="line"><span class="comment">//        BufferedReader fr = new BufferedReader(new InputStreamReader(i, &quot;UTF-8&quot;));</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">c</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        pw.println(<span class="string">&quot;HTTP/1.1 200 OK&quot;</span>);</span><br><span class="line">        <span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> line.substring(line.lastIndexOf(<span class="string">&quot;.&quot;</span>)+<span class="number">1</span>);</span><br><span class="line">        System.out.println(s);</span><br><span class="line">        pw.println(<span class="string">&quot;Content-Type: &quot;</span>+contentMap.get(s));</span><br><span class="line">        pw.println(<span class="string">&quot;Content-Length: &quot;</span> + i.available());</span><br><span class="line">        pw.println(<span class="string">&quot;Server: hello&quot;</span>);</span><br><span class="line">        pw.println(<span class="string">&quot;Date: &quot;</span> + <span class="keyword">new</span> <span class="title class_">Date</span>());</span><br><span class="line">        pw.println(<span class="string">&quot;&quot;</span>);</span><br><span class="line">        pw.flush();</span><br><span class="line">        <span class="type">byte</span>[] buff = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">1024</span>];</span><br><span class="line">        <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> ((len = i.read(buff)) != -<span class="number">1</span>) &#123;</span><br><span class="line">           out.write(buff, <span class="number">0</span> , len);</span><br><span class="line">        &#125;</span><br><span class="line">        pw.flush();</span><br><span class="line">        i.close();</span><br><span class="line">        pw.close();</span><br><span class="line">        reader.close();</span><br><span class="line">        client.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<ul>
<li>启动HttpServer2,开放8888端口:</li>
<li>客户端访问，可看到图片也访问到了<br><img src="https://raw.githubusercontent.com/hufanglei/img-csdn/main/img/2025-1-13/aca0c92e8a9b93e3f612e3aa712fbeed_1737625704602.png" alt="在这里插入图片描述"></li>
</ul>
<h1 id="3-2简易web服务器版本3-访问外链地址测试"><a href="#3-2简易web服务器版本3-访问外链地址测试" class="headerlink" title="3.2简易web服务器版本3-访问外链地址测试"></a>3.2简易web服务器版本3-访问外链地址测试</h1><p>版本3，其实也可以访问到外链地址，我们测试下：<br>修改index.html</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;utf-8&quot;</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">title</span>&gt;</span>index.html<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">	hello world</span><br><span class="line">	<span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;1.jpg&quot;</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;login.html&quot;</span>&gt;</span>登陆<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>我们在webroot下新建login.html<br><img src="https://raw.githubusercontent.com/hufanglei/img-csdn/main/img/2025-1-13/a85559857dcdf9af09cec0a05b67de30_1737625704602.png" alt="在这里插入图片描述">login.html</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">title</span>&gt;</span><span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    this is sign in html</span><br><span class="line">    这是登陆页面奥</span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>
<ul>
<li>测试下能否访问到<br><img src="https://raw.githubusercontent.com/hufanglei/img-csdn/main/img/2025-1-13/0bcc5d0093a92a1318f3251a6c433c72_1737625704602.png" alt="在这里插入图片描述"></li>
<li>点击登陆链接</li>
</ul>
<p><img src="https://raw.githubusercontent.com/hufanglei/img-csdn/main/img/2025-1-13/e9088efc85fd479c91ce81710c7cd54b_1737625704602.png" alt="在这里插入图片描述"><br>测试没有问题，可以访问到login.html</p>
<h1 id="4-简易web服务器-版本4-连接池版"><a href="#4-简易web服务器-版本4-连接池版" class="headerlink" title="4.简易web服务器-版本4-连接池版"></a>4.简易web服务器-版本4-连接池版</h1><p>上面的代码有啥问题吗，其实每次都是重新开个线程，比较消耗资源，我们可以使用连接池进行，管理，这样对以后的线程的监控，管理等都可以有效控制。阿里代码规范中，也有说到，凡是创建线程，必须通过，线程池，现在我们进行优化，其实只修改HttpServer2主类即可。<br>原来的代码:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.net.ServerSocket;</span><br><span class="line"><span class="keyword">import</span> java.net.Socket;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HttpServer2</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="comment">//启动服务器，监听8888端口</span></span><br><span class="line">        <span class="type">ServerSocket</span> <span class="variable">server</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ServerSocket</span>(<span class="number">8888</span>);</span><br><span class="line">        <span class="keyword">while</span> (!Thread.interrupted()) &#123;</span><br><span class="line">            <span class="comment">//不停的接收客户端请求</span></span><br><span class="line">            <span class="type">Socket</span> <span class="variable">client</span> <span class="operator">=</span> server.accept();</span><br><span class="line">             <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">ServerThread</span>(client)).start();</span><br><span class="line">        &#125;</span><br><span class="line">        server.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>修改为:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HttpServer2</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="type">ExecutorService</span> <span class="variable">pool</span> <span class="operator">=</span> Executors.newCachedThreadPool();</span><br><span class="line">        <span class="comment">//启动服务器，监听8888端口</span></span><br><span class="line">        <span class="type">ServerSocket</span> <span class="variable">server</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ServerSocket</span>(<span class="number">8888</span>);</span><br><span class="line">        <span class="keyword">while</span> (!Thread.interrupted()) &#123;</span><br><span class="line">            <span class="comment">//不停的接收客户端请求</span></span><br><span class="line">            <span class="type">Socket</span> <span class="variable">client</span> <span class="operator">=</span> server.accept();</span><br><span class="line">            pool.execute(<span class="keyword">new</span> <span class="title class_">ServerThread</span>(client));</span><br><span class="line">        &#125;</span><br><span class="line">        server.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>启动httpserver2主类</li>
<li>测试<br><img src="https://raw.githubusercontent.com/hufanglei/img-csdn/main/img/2025-1-13/e8dff4091e25bcca5e130ac816afb148_1737625716984.png" alt="在这里插入图片描述"><br>完美，结果没问题。</li>
</ul>
<hr>
<p>现在简易的web服务器已经实现了，其实还有需要可以优化的地方。比如httpservet的支持等，tomcat的源码中可以多多去研读。</p>
<hr>
<p>完</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://hufanglei.github.io/2020/02/04/java%E5%B9%B6%E5%8F%91%E5%8E%9F%E7%90%86%E5%AE%9E%E6%88%98(13)--%E7%BA%BF%E7%A8%8B%E6%B1%A0%E5%92%8CExecutors/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="胡方雷">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="个人博客">
      <meta itemprop="description" content="直到这一刻微笑着说话为止，我至少留下了一公升眼泪">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | 个人博客">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2020/02/04/java%E5%B9%B6%E5%8F%91%E5%8E%9F%E7%90%86%E5%AE%9E%E6%88%98(13)--%E7%BA%BF%E7%A8%8B%E6%B1%A0%E5%92%8CExecutors/" class="post-title-link" itemprop="url">java并发原理实战(13)--线程池和Executors</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2020-02-04 20:09:42" itemprop="dateCreated datePublished" datetime="2020-02-04T20:09:42+08:00">2020-02-04</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2025-01-24 11:37:59" itemprop="dateModified" datetime="2025-01-24T11:37:59+08:00">2025-01-24</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/" itemprop="url" rel="index"><span itemprop="name">并发编程</span></a>
        </span>
    </span>

  
    <span class="post-meta-break"></span>
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>8.4k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>8 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <span id="more"></span>

<p>@<a href="%E7%BA%BF%E7%A8%8B%E6%B1%A0">toc</a></p>
<h1 id="一-线程池简介"><a href="#一-线程池简介" class="headerlink" title="一. 线程池简介"></a>一. 线程池简介</h1><h2 id="1-线程池的概念："><a href="#1-线程池的概念：" class="headerlink" title="1. 线程池的概念："></a>1. 线程池的概念：</h2><p>​          线程池就是首先创建一些线程，它们的集合称为线程池。使用线程池可以很好地提高性能，线程池在系统启动时即创建大量空闲的线程，程序将一个任务传给线程池，线程池就会启动一条线程来执行这个任务，执行结束以后，该线程并不会死亡，而是再次返回线程池中成为空闲状态，等待执行下一个任务。</p>
<h2 id="2-线程池的工作机制"><a href="#2-线程池的工作机制" class="headerlink" title="2. 线程池的工作机制"></a>2. 线程池的工作机制</h2><p>​         在线程池的编程模式下，任务是提交给整个线程池，而不是直接提交给某个线程，线程池在拿到任务后，就在内部寻找是否有空闲的线程，如果有，则将任务交给某个空闲的线程。</p>
<p>​         一个线程同时只能执行一个任务，但可以同时向一个线程池提交多个任务。</p>
<h2 id="3-使用线程池的原因："><a href="#3-使用线程池的原因：" class="headerlink" title="3. 使用线程池的原因："></a>3. 使用线程池的原因：</h2><p>​        多线程运行时间，系统不断的启动和关闭新线程，成本非常高，会过渡消耗系统资源，以及过渡切换线程的危险，从而可能导致系统资源的崩溃。这时，线程池就是最好的选择了。</p>
<h1 id="二-5种常见的线程池详解"><a href="#二-5种常见的线程池详解" class="headerlink" title="二. 5种常见的线程池详解"></a>二. 5种常见的线程池详解</h1><h2 id="1-线程池的返回值ExecutorService简介："><a href="#1-线程池的返回值ExecutorService简介：" class="headerlink" title="1. 线程池的返回值ExecutorService简介："></a>1. 线程池的返回值ExecutorService简介：</h2><p>​         ExecutorService是Java提供的用于管理线程池的接口。该接口的两个作用：控制线程数量和重用线程</p>
<h2 id="2-具体的5种常用的线程池实现如下：（返回值都是ExecutorService）"><a href="#2-具体的5种常用的线程池实现如下：（返回值都是ExecutorService）" class="headerlink" title="2. 具体的5种常用的线程池实现如下：（返回值都是ExecutorService）"></a>2. 具体的5种常用的线程池实现如下：（返回值都是ExecutorService）</h2><h3 id="①Executors-newCacheThreadPool-："><a href="#①Executors-newCacheThreadPool-：" class="headerlink" title="①Executors.newCacheThreadPool()："></a>①Executors.newCacheThreadPool()：</h3><p>可缓存线程池，先查看池中有没有以前建立的线程，如果有，就直接使用。如果没有，就建一个新的线程加入池中，缓存型池子通常用于执行一些生存期很短的异步型任务</p>
<p>​         示例代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.ExecutorService;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.Executors;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ThreadPoolExecutorTest</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//创建一个可缓存线程池</span></span><br><span class="line">        <span class="type">ExecutorService</span> <span class="variable">cachedThreadPool</span> <span class="operator">=</span> Executors.newCachedThreadPool();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">//sleep可明显看到使用的是线程池里面以前的线程，没有创建新的线程</span></span><br><span class="line">                Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            cachedThreadPool.execute(<span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;</span><br><span class="line">                <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">                    <span class="comment">//打印正在执行的缓存线程信息</span></span><br><span class="line">                    System.out.println(Thread.currentThread().getName()+<span class="string">&quot;正在被执行&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出结果：</p>
<p>pool-1-thread-1正在被执行<br>pool-1-thread-1正在被执行<br>pool-1-thread-1正在被执行<br>pool-1-thread-1正在被执行<br>pool-1-thread-1正在被执行<br>pool-1-thread-1正在被执行<br>pool-1-thread-1正在被执行<br>pool-1-thread-1正在被执行<br>pool-1-thread-1正在被执行<br>pool-1-thread-1正在被执行</p>
<p>线程池为无限大，当执行当前任务时上一个任务已经完成，会复用执行上一个任务的线程，而不用每次新建线程</p>
<h3 id="②-Executors-newFixedThreadPool-int-n-："><a href="#②-Executors-newFixedThreadPool-int-n-：" class="headerlink" title="② Executors.newFixedThreadPool(int n)："></a>② Executors.newFixedThreadPool(int n)：</h3><p>创建一个可重用固定个数的线程池，以共享的无界队列方式来运行这些线程。</p>
<p><em>示例代码：</em></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.ExecutorService;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.Executors;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ThreadPoolExecutorTest</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//创建一个可重用固定个数的线程池</span></span><br><span class="line">        <span class="type">ExecutorService</span> <span class="variable">fixedThreadPool</span> <span class="operator">=</span> Executors.newFixedThreadPool(<span class="number">3</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">            fixedThreadPool.execute(<span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;</span><br><span class="line">                <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        <span class="comment">//打印正在执行的缓存线程信息</span></span><br><span class="line">                        System.out.println(Thread.currentThread().getName()+<span class="string">&quot;正在被执行&quot;</span>);</span><br><span class="line">                        Thread.sleep(<span class="number">2000</span>);</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>输出结果：</p>
<p>pool-1-thread-1正在被执行<br>pool-1-thread-2正在被执行<br>pool-1-thread-3正在被执行<br>pool-1-thread-1正在被执行<br>pool-1-thread-2正在被执行<br>pool-1-thread-3正在被执行<br>pool-1-thread-1正在被执行<br>pool-1-thread-2正在被执行<br>pool-1-thread-3正在被执行<br>pool-1-thread-1正在被执行</p>
<p>因为线程池大小为3，每个任务输出打印结果后sleep 2秒，所以每两秒打印3个结果。<br>定长线程池的大小最好根据系统资源进行设置。如Runtime.getRuntime().availableProcessors()</p>
<h3 id="③Executors-newScheduledThreadPool-int-n"><a href="#③Executors-newScheduledThreadPool-int-n" class="headerlink" title="③Executors.newScheduledThreadPool(int n)"></a>③Executors.newScheduledThreadPool(int n)</h3><p>创建一个定长线程池，支持定时及周期性任务执行</p>
<p><em>延迟执行示例代码：</em></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.Executors;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.ScheduledExecutorService;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeUnit;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ThreadPoolExecutorTest</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//创建一个定长线程池，支持定时及周期性任务执行——延迟执行</span></span><br><span class="line">        <span class="type">ScheduledExecutorService</span> <span class="variable">scheduledThreadPool</span> <span class="operator">=</span> Executors.newScheduledThreadPool(<span class="number">5</span>);</span><br><span class="line">        <span class="comment">//延迟1秒执行</span></span><br><span class="line">        scheduledThreadPool.schedule(<span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;</span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;延迟1秒执行&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="number">1</span>, TimeUnit.SECONDS);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>输出结果：延迟1秒执行</p>
<p>定期执行示例代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.Executors;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.ScheduledExecutorService;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeUnit;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ThreadPoolExecutorTest</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//创建一个定长线程池，支持定时及周期性任务执行——定期执行</span></span><br><span class="line">        <span class="type">ScheduledExecutorService</span> <span class="variable">scheduledThreadPool</span> <span class="operator">=</span> Executors.newScheduledThreadPool(<span class="number">5</span>);</span><br><span class="line">        <span class="comment">//延迟1秒后每3秒执行一次</span></span><br><span class="line">        scheduledThreadPool.scheduleAtFixedRate(<span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;</span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;延迟1秒后每3秒执行一次&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="number">1</span>, <span class="number">3</span>, TimeUnit.SECONDS);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>输出结果：</p>
<p>延迟1秒后每3秒执行一次<br>延迟1秒后每3秒执行一次<br>………….</p>
<h3 id="④-Executors-newSingleThreadExecutor-："><a href="#④-Executors-newSingleThreadExecutor-：" class="headerlink" title="④ Executors.newSingleThreadExecutor()："></a>④ Executors.newSingleThreadExecutor()：</h3><p>创建一个单线程化的线程池，它只会用唯一的工作线程来执行任务，保证所有任务按照指定顺序(FIFO, LIFO, 优先级)执行。</p>
<p><em>示例代码：</em> </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.ExecutorService;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.Executors;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestThreadPoolExecutor</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//创建一个单线程化的线程池</span></span><br><span class="line">        <span class="type">ExecutorService</span> <span class="variable">singleThreadExecutor</span> <span class="operator">=</span> Executors.newSingleThreadExecutor();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">final</span> <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> i;</span><br><span class="line">            singleThreadExecutor.execute(<span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;</span><br><span class="line">                <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        <span class="comment">//结果依次输出，相当于顺序执行各个任务</span></span><br><span class="line">                        System.out.println(Thread.currentThread().getName()+<span class="string">&quot;正在被执行,打印的值是:&quot;</span>+index);</span><br><span class="line">                        Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>pool-1-thread-1正在被执行,打印的值是:0<br>pool-1-thread-1正在被执行,打印的值是:1<br>pool-1-thread-1正在被执行,打印的值是:2<br>pool-1-thread-1正在被执行,打印的值是:3<br>pool-1-thread-1正在被执行,打印的值是:4<br>pool-1-thread-1正在被执行,打印的值是:5<br>pool-1-thread-1正在被执行,打印的值是:6<br>pool-1-thread-1正在被执行,打印的值是:7<br>pool-1-thread-1正在被执行,打印的值是:8<br>pool-1-thread-1正在被执行,打印的值是:9</p>
<h3 id="⑤-Executors-newWorkStealingPool-："><a href="#⑤-Executors-newWorkStealingPool-：" class="headerlink" title="⑤ Executors.newWorkStealingPool()："></a>⑤ Executors.newWorkStealingPool()：</h3><p>jdk1.8新增的： 每个线程都有要处理的队列中的任务，如果其中的线程完成自己队列中的任务，</p>
<p>  那么它可以去其他线程中获取其他线程的任务去执行</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.ExecutorService;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.Executors;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeUnit;</span><br><span class="line"> </span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 线程池</span></span><br><span class="line"><span class="comment"> *    1.固定个数的线程池</span></span><br><span class="line"><span class="comment"> *    2.缓存线程池，开始线程数0</span></span><br><span class="line"><span class="comment"> *         如果需要线程，当前线程池没有，那么创建线程池</span></span><br><span class="line"><span class="comment"> *         如果需要线程，线程池中有没有使用的线程，那么使用已经存在的线程</span></span><br><span class="line"><span class="comment"> *         如果线程池中线程超过60秒(默认)没有使用，那么该线程停止</span></span><br><span class="line"><span class="comment"> *    3.只有1个线程的线程池</span></span><br><span class="line"><span class="comment"> *         保证线程执行的先后顺序</span></span><br><span class="line"><span class="comment"> *    4.ScheduledPool</span></span><br><span class="line"><span class="comment"> *          和DelayedQueue类似,定时执行</span></span><br><span class="line"><span class="comment"> *    5.WorkStealingPool(任务窃取，都是守护线程)</span></span><br><span class="line"><span class="comment"> *          每个线程都有要处理的队列中的任务，如果其中的线程完成自己队列中的任务，</span></span><br><span class="line"><span class="comment"> *          那么它可以去其他线程中获取其他线程的任务去执行</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo</span> &#123;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">        4</span></span><br><span class="line"><span class="comment">        1000:ForkJoinPool-1-worker-1</span></span><br><span class="line"><span class="comment">        1000:ForkJoinPool-1-worker-0</span></span><br><span class="line"><span class="comment">        2000:ForkJoinPool-1-worker-2</span></span><br><span class="line"><span class="comment">        3000:ForkJoinPool-1-worker-3</span></span><br><span class="line"><span class="comment">        2000:ForkJoinPool-1-worker-1</span></span><br><span class="line"><span class="comment">        public static ExecutorService newWorkStealingPool() &#123;</span></span><br><span class="line"><span class="comment">        return new ForkJoinPool</span></span><br><span class="line"><span class="comment">            (Runtime.getRuntime().availableProcessors(),</span></span><br><span class="line"><span class="comment">             ForkJoinPool.defaultForkJoinWorkerThreadFactory,</span></span><br><span class="line"><span class="comment">             null, true);</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="comment">// 根据cpu是几核来开启几个线程</span></span><br><span class="line">        <span class="type">ExecutorService</span> <span class="variable">service</span> <span class="operator">=</span> Executors.newWorkStealingPool();</span><br><span class="line">        <span class="comment">// 查看当前计算机是几核</span></span><br><span class="line">        System.out.println(Runtime.getRuntime().availableProcessors());</span><br><span class="line">        service.execute(<span class="keyword">new</span> <span class="title class_">R</span>(<span class="number">1000</span>));</span><br><span class="line">        service.execute(<span class="keyword">new</span> <span class="title class_">R</span>(<span class="number">2000</span>));</span><br><span class="line">        service.execute(<span class="keyword">new</span> <span class="title class_">R</span>(<span class="number">3000</span>));</span><br><span class="line">        service.execute(<span class="keyword">new</span> <span class="title class_">R</span>(<span class="number">1000</span>));</span><br><span class="line">        service.execute(<span class="keyword">new</span> <span class="title class_">R</span>(<span class="number">2000</span>));</span><br><span class="line"> </span><br><span class="line">        <span class="comment">// WorkStealing是精灵线程(守护线程、后台线程)，主线程不阻塞，看不到输出。</span></span><br><span class="line">        <span class="comment">// 虚拟机不停止，守护线程不停止</span></span><br><span class="line">        System.in.read();</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">R</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line">        <span class="type">int</span> time;</span><br><span class="line"> </span><br><span class="line">        <span class="keyword">public</span> <span class="title function_">R</span><span class="params">(<span class="type">int</span> time)</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>.time = time;</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                TimeUnit.MILLISECONDS.sleep(time);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(time + <span class="string">&quot;:&quot;</span> + Thread.currentThread().getName());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>原文链接：<a target="_blank" rel="noopener" href="https://blog.csdn.net/mediocre117/article/details/73374876">https://blog.csdn.net/mediocre117/article/details/73374876</a></p>
<h1 id="三-缓冲队列BlockingQueue和自定义线程池ThreadPoolExecutor"><a href="#三-缓冲队列BlockingQueue和自定义线程池ThreadPoolExecutor" class="headerlink" title="三. 缓冲队列BlockingQueue和自定义线程池ThreadPoolExecutor"></a>三. 缓冲队列BlockingQueue和自定义线程池ThreadPoolExecutor</h1><h2 id="1-缓冲队列BlockingQueue简介："><a href="#1-缓冲队列BlockingQueue简介：" class="headerlink" title="1.缓冲队列BlockingQueue简介："></a>1.缓冲队列BlockingQueue简介：</h2><p>​          BlockingQueue是双缓冲队列。BlockingQueue内部使用两条队列，允许两个线程同时向队列一个存储，一个取出操作。在保证并发安全的同时，提高了队列的存取效率。</p>
<h2 id="2-常用的几种BlockingQueue："><a href="#2-常用的几种BlockingQueue：" class="headerlink" title="2.常用的几种BlockingQueue："></a>2.常用的几种BlockingQueue：</h2><ul>
<li>ArrayBlockingQueue（int i）:规定大小的BlockingQueue，其构造必须指定大小。其所含的对象是FIFO顺序排序的。</li>
<li>LinkedBlockingQueue（）或者（int i）:大小不固定的BlockingQueue，若其构造时指定大小，生成的BlockingQueue有大小限制，不指定大小，其大小有Integer.MAX_VALUE来决定。其所含的对象是FIFO顺序排序的。</li>
<li>PriorityBlockingQueue（）或者（int i）:类似于LinkedBlockingQueue，但是其所含对象的排序不是FIFO，而是依据对象的自然顺序或者构造函数的Comparator决定。</li>
<li>SynchronizedQueue（）:特殊的BlockingQueue，对其的操作必须是放和取交替完成。</li>
</ul>
<h2 id="3-自定义线程池（ThreadPoolExecutor和BlockingQueue连用）："><a href="#3-自定义线程池（ThreadPoolExecutor和BlockingQueue连用）：" class="headerlink" title="3.自定义线程池（ThreadPoolExecutor和BlockingQueue连用）："></a>3.自定义线程池（ThreadPoolExecutor和BlockingQueue连用）：</h2><p>​     <em>自定义线程池，可以用ThreadPoolExecutor类创建，它有多个构造方法来创建线程池。</em></p>
<p>​    <em>常见的构造函数：ThreadPoolExecutor(int corePoolSize, int maximumPoolSize, long keepAliveTime, TimeUnit unit, BlockingQueue<Runnable> workQueue)</em></p>
<p>示例代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.ArrayBlockingQueue;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.BlockingQueue;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.ThreadPoolExecutor;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeUnit;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">TempThread</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 打印正在执行的缓存线程信息</span></span><br><span class="line">        System.out.println(Thread.currentThread().getName() + <span class="string">&quot;正在被执行&quot;</span>);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// sleep一秒保证3个任务在分别在3个线程上执行</span></span><br><span class="line">            Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestThreadPoolExecutor</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 创建数组型缓冲等待队列</span></span><br><span class="line">        BlockingQueue&lt;Runnable&gt; bq = <span class="keyword">new</span> <span class="title class_">ArrayBlockingQueue</span>&lt;Runnable&gt;(<span class="number">10</span>);</span><br><span class="line">        <span class="comment">// ThreadPoolExecutor:创建自定义线程池，池中保存的线程数为3，允许最大的线程数为6</span></span><br><span class="line">        <span class="type">ThreadPoolExecutor</span> <span class="variable">tpe</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>(<span class="number">3</span>, <span class="number">6</span>, <span class="number">50</span>, TimeUnit.MILLISECONDS, bq);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 创建3个任务</span></span><br><span class="line">        <span class="type">Runnable</span> <span class="variable">t1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TempThread</span>();</span><br><span class="line">        <span class="type">Runnable</span> <span class="variable">t2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TempThread</span>();</span><br><span class="line">        <span class="type">Runnable</span> <span class="variable">t3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TempThread</span>();</span><br><span class="line">        <span class="comment">// Runnable t4 = new TempThread();</span></span><br><span class="line">        <span class="comment">// Runnable t5 = new TempThread();</span></span><br><span class="line">        <span class="comment">// Runnable t6 = new TempThread();</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3个任务在分别在3个线程上执行</span></span><br><span class="line">        tpe.execute(t1);</span><br><span class="line">        tpe.execute(t2);</span><br><span class="line">        tpe.execute(t3);</span><br><span class="line">        <span class="comment">// tpe.execute(t4);</span></span><br><span class="line">        <span class="comment">// tpe.execute(t5);</span></span><br><span class="line">        <span class="comment">// tpe.execute(t6);</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 关闭自定义线程池</span></span><br><span class="line">        tpe.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出结果：</p>
<p>pool-1-thread-1正在被执行<br>pool-1-thread-2正在被执行<br>pool-1-thread-3正在被执行</p>
<hr>
<p>完</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://hufanglei.github.io/2020/02/04/java%E5%B9%B6%E5%8F%91%E5%8E%9F%E7%90%86%E5%AE%9E%E6%88%98(12)--%E5%90%8C%E6%AD%A5%E5%B9%B6%E5%8F%91%E5%AE%B9%E5%99%A8/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="胡方雷">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="个人博客">
      <meta itemprop="description" content="直到这一刻微笑着说话为止，我至少留下了一公升眼泪">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | 个人博客">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2020/02/04/java%E5%B9%B6%E5%8F%91%E5%8E%9F%E7%90%86%E5%AE%9E%E6%88%98(12)--%E5%90%8C%E6%AD%A5%E5%B9%B6%E5%8F%91%E5%AE%B9%E5%99%A8/" class="post-title-link" itemprop="url">java并发原理实战(12)--同步并发容器</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2020-02-04 12:53:01" itemprop="dateCreated datePublished" datetime="2020-02-04T12:53:01+08:00">2020-02-04</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2025-01-24 11:37:59" itemprop="dateModified" datetime="2025-01-24T11:37:59+08:00">2025-01-24</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/" itemprop="url" rel="index"><span itemprop="name">并发编程</span></a>
        </span>
    </span>

  
    <span class="post-meta-break"></span>
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>8k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>7 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <span id="more"></span>

<p>@[TOC]</p>
<h1 id="1-fork-join框架"><a href="#1-fork-join框架" class="headerlink" title="1.fork&#x2F;join框架"></a>1.fork&#x2F;join框架</h1><ul>
<li><p>多线程的目的不仅仅是提高程序运行的性能。</p>
</li>
<li><p>但是可以充分利用cpu资源。<br><img src="https://raw.githubusercontent.com/hufanglei/img-csdn/main/img/2025-1-13/449d68b8b49f0524748ee78c953e777b_1737625716984.png" alt="在这里插入图片描述"></p>
</li>
</ul>
<h3 id="示例代码"><a href="#示例代码" class="headerlink" title="示例代码:"></a>示例代码:</h3><p>计算1+2+3+…+100的和：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.ForkJoinPool;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.Future;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.RecursiveTask;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo</span> <span class="keyword">extends</span> <span class="title class_">RecursiveTask</span>&lt;Integer&gt; &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> begin;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> end;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Demo</span><span class="params">(<span class="type">int</span> begin, <span class="type">int</span> end)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.begin = begin;</span><br><span class="line">        <span class="built_in">this</span>.end = end;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> Integer <span class="title function_">compute</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//拆分任务</span></span><br><span class="line">        <span class="keyword">if</span> (end - begin &lt;= <span class="number">2</span>) &#123;</span><br><span class="line">            <span class="comment">//计算</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> begin; i &lt;= end; i++) &#123;</span><br><span class="line">                sum += i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="type">Demo</span> <span class="variable">d1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Demo</span>(begin, (begin + end) / <span class="number">2</span>);</span><br><span class="line">            <span class="type">Demo</span> <span class="variable">d2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Demo</span>((begin + end) / <span class="number">2</span> + <span class="number">1</span>, end);</span><br><span class="line">            <span class="comment">//执行任务</span></span><br><span class="line">            d1.fork();</span><br><span class="line">            d2.fork();</span><br><span class="line"></span><br><span class="line">            <span class="type">Integer</span> <span class="variable">a</span> <span class="operator">=</span> d1.join();</span><br><span class="line">            <span class="type">Integer</span> <span class="variable">b</span> <span class="operator">=</span>d2.join();</span><br><span class="line">            sum = a + b;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//拆分</span></span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception&#123;</span><br><span class="line">        <span class="type">ForkJoinPool</span> <span class="variable">pool</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ForkJoinPool</span>();</span><br><span class="line">        Future&lt;Integer&gt; future = pool.submit(<span class="keyword">new</span> <span class="title class_">Demo</span>(<span class="number">1</span>, <span class="number">100</span>));</span><br><span class="line">        System.out.println(<span class="string">&quot;....&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;计算的值为: &quot;</span> + future.get());</span><br><span class="line">    &#125;</span><br><span class="line">      <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * JDK8 的写法</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test3</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">long</span> <span class="variable">start</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line"></span><br><span class="line">        <span class="type">Long</span> <span class="variable">sum</span> <span class="operator">=</span> LongStream.rangeClosed(<span class="number">0L</span>, <span class="number">100</span>).parallel().sum();</span><br><span class="line">        System.out.println(sum);</span><br><span class="line"></span><br><span class="line">        <span class="type">long</span> <span class="variable">end</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">        System.out.println(<span class="string">&quot;耗费的时间为: &quot;</span> + (end - start)); </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行结果:<br><img src="https://raw.githubusercontent.com/hufanglei/img-csdn/main/img/2025-1-13/3829c086ff16e0380f909b326f993409_1737625716984.png" alt="在这里插入图片描述"></p>
<h1 id="2-同步容器和并发容器"><a href="#2-同步容器和并发容器" class="headerlink" title="2.同步容器和并发容器"></a>2.同步容器和并发容器</h1><h2 id="①同步容器"><a href="#①同步容器" class="headerlink" title="①同步容器:"></a>①同步容器:</h2><p>在 Java 中，同步容器主要包括 2 类：</p>
<p>Vector、Stack、HashTable<br>Vector 实现了 List 接口，Vector 实际上就是一个数组，和 ArrayList 类似，但是 Vector 中的方法都是 synchronized 方法，即进行了同步措施。<br>Stack 也是一个同步容器，它的方法也用 synchronized 进行了同步，它实际上是继承于 Vector 类。<br>HashTable 实现了 Map 接口，它和 HashMap 很相似，但是 HashTable 进行了同步处理，而 HashMap 没有。<br>Collections 类中提供的静态工厂方法创建的类（由 Collections.synchronizedXxxx 等方法）</p>
<p>原文链接：<a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_20499001/article/details/89031480">https://blog.csdn.net/qq_20499001&#x2F;article&#x2F;details&#x2F;89031480</a></p>
<p>示例代码:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">       List&lt;String&gt; s =  <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">       <span class="comment">//转成list的同步容器</span></span><br><span class="line">        List&lt;String&gt; strings = Collections.synchronizedList(s);</span><br><span class="line">        HashMap&lt;String, Object&gt; res = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        <span class="comment">//转成map的同步容器</span></span><br><span class="line">        Map&lt;String, Object&gt; stringObjectMap = Collections.synchronizedMap(res);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>查看collections的源代码，发现增删改查的方法都是同步的方法。<br><img src="https://raw.githubusercontent.com/hufanglei/img-csdn/main/img/2025-1-13/79ca6c2b0e80608e282368f4562efcf1_1737625716984.png" alt="在这里插入图片描述"></p>
<p>同步容器的缺陷<br>同步容器的同步原理就是在方法上用 synchronized 修饰。那么，这些方法每次只允许一个线程调用执行。</p>
<p>性能问题</p>
<p>由于被 synchronized 修饰的方法，每次只允许一个线程执行，其他试图访问这个方法的线程只能等待。显然，这种方式比没有使用 synchronized 的容器性能要差。</p>
<p>安全问题</p>
<p>同步容器真的一定安全吗？</p>
<p>答案是：未必。同步容器未必真的安全。在做复合操作时，仍然需要加锁来保护。</p>
<p>常见复合操作如下：</p>
<p>迭代：反复访问元素，直到遍历完全部元素；<br>跳转：根据指定顺序寻找当前元素的下一个（下 n 个）元素；<br>条件运算：例如若没有则添加等；</p>
<p>原文链接：<a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_20499001/article/details/89031480">https://blog.csdn.net/qq_20499001/article/details/89031480</a></p>
<h2 id="②并发容器"><a href="#②并发容器" class="headerlink" title="②并发容器"></a>②并发容器</h2><p>并发容器是在多线程情况下，解决同步容器性能差的问题。</p>
<p>并发容器<br>JDK 的 java.util.concurrent 包（即 juc）中提供了几个非常有用的并发容器。</p>
<p>CopyOnWriteArrayList - 线程安全的 ArrayList<br>CopyOnWriteArraySet - 线程安全的 Set，它内部包含了一个 CopyOnWriteArrayList，因此本质上是由 CopyOnWriteArrayList 实现的。<br>ConcurrentSkipListSet - 相当于线程安全的 TreeSet。它是有序的 Set。它由 ConcurrentSkipListMap 实现。<br>ConcurrentHashMap - 线程安全的 HashMap。采用分段锁实现高效并发。<br>ConcurrentSkipListMap - 线程安全的有序 Map。使用跳表实现高效并发。<br>ConcurrentLinkedQueue - 线程安全的无界队列。底层采用单链表。支持 FIFO。<br>ConcurrentLinkedDeque - 线程安全的无界双端队列。底层采用双向链表。支持 FIFO 和 FILO。<br>ArrayBlockingQueue - 数组实现的阻塞队列。<br>LinkedBlockingQueue - 链表实现的阻塞队列。<br>LinkedBlockingDeque - 双向链表实现的双端阻塞队列。</p>
<h3 id="ConcurrentHashMap"><a href="#ConcurrentHashMap" class="headerlink" title="ConcurrentHashMap"></a>ConcurrentHashMap</h3><p>要点</p>
<ul>
<li>作用：ConcurrentHashMap 是线程安全的 HashMap。</li>
<li>原理：JDK6 与 JDK7 中，ConcurrentHashMap 采用了分段锁机制。JDK8 中，摒弃了锁分段机制，改为利用 CAS 算法。</li>
</ul>
<p>原文链接：<a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_20499001/article/details/89031480">https://blog.csdn.net/qq_20499001/article/details/89031480</a></p>
<h3 id="CopyOnWriteArrayList"><a href="#CopyOnWriteArrayList" class="headerlink" title="CopyOnWriteArrayList"></a>CopyOnWriteArrayList</h3><p>要点</p>
<p>作用：CopyOnWrite 字面意思为写入时复制。CopyOnWriteArrayList 是线程安全的 ArrayList。<br>原理：<br>在 CopyOnWriteAarrayList 中，读操作不同步，因为它们在内部数组的快照上工作，所以多个迭代器可以同时遍历而不会相互阻塞（1,2,4）。<br>所有的写操作都是同步的。他们在备份数组（3）的副本上工作。写操作完成后，后备阵列将被替换为复制的阵列，并释放锁定。支持数组变得易变，所以替换数组的调用是原子（5）。<br>写操作后创建的迭代器将能够看到修改的结构（6,7）。<br>写时复制集合返回的迭代器不会抛出 ConcurrentModificationException，因为它们在数组的快照上工作，并且无论后续的修改（2,4）如何，都会像迭代器创建时那样完全返回元素。</p>
<p>添加操作</p>
<ul>
<li>添加的逻辑很简单，先将原容器 copy 一份，然后在新副本上执行写操作，之后再切换引用。当然此过程是要加锁的。</li>
</ul>
<p>删除操作</p>
<ul>
<li>删除操作同理，将除要删除元素之外的其他元素拷贝到新副本中，然后切换引用，将原容器引用指向新副本。同属写操作，需要加锁。</li>
</ul>
<p>读操作</p>
<ul>
<li>CopyOnWriteArrayList 的读操作是不用加锁的，性能很高。</li>
</ul>
<h3 id="CopyOnWriteArraySet"><a href="#CopyOnWriteArraySet" class="headerlink" title="CopyOnWriteArraySet"></a>CopyOnWriteArraySet</h3><p>当我们往一个容器添加元素的时候，不直接往当前容器添加，而是先将当前容器进行Copy，复制出一个新的容器，然后向新的容器里添加元素，添加完元素之后，再将原容器的引用指向新的容器。这样做的好处是我们可以对CopyOnWrite容器进行并发的读，而不需要加锁，因为在当前读的容器中不会添加任何元素。所以CopyOnWrite容器是一种读写分离的思想，读和写对应不同的容器。<br>原文链接：<a target="_blank" rel="noopener" href="https://blog.csdn.net/wang7807564/article/details/80048576">https://blog.csdn.net/wang7807564/article/details/80048576</a></p>
<h3 id="BlockingQueue"><a href="#BlockingQueue" class="headerlink" title="BlockingQueue"></a>BlockingQueue</h3><p>这种并发容器，会自动实现阻塞式的生产者&#x2F;消费者模式。使用队列解耦合，在实现异步事物的时候很有用。下面的例子，实现了阻塞队列：</p>
<h3 id="LinkedBlockingQueue"><a href="#LinkedBlockingQueue" class="headerlink" title="LinkedBlockingQueue"></a>LinkedBlockingQueue</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> BlockingQueue&lt;String&gt; strs = <span class="keyword">new</span> <span class="title class_">LinkedBlockingQueue</span>&lt;&gt;(<span class="number">10</span>);</span><br><span class="line">strs.put(<span class="string">&quot;a&quot;</span> + i); <span class="comment">//加入队列，如果满了，就会等待</span></span><br><span class="line">strs.take(); <span class="comment">//取出队列元素，如果空了，就会等待</span></span><br></pre></td></tr></table></figure>

<p>在实例化时，可以指定具体的队列容量。<br>在加入成员的时候，除了使用put方法还可以使用其他方法： </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Str.add(“aaa”);</span><br><span class="line"><span class="comment">/* add如果在队列满了之后，再加入成员会抛出异常，而这种情况下，put方法会一直等待被消费掉。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">Str.offer(“aaa”);</span><br><span class="line"><span class="comment">/* offer添加成员的时候，会有boolean类型的返回值，如果添加成功，会返回true，如果添加失败，会返回false.除此之外，offer还可以按时段进行添加，例如：</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">strs.offer(<span class="string">&quot;aaa&quot;</span>, <span class="number">1</span>, TimeUnit.SECONDS);</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">如果队列满了，等待1秒，再进行成员的添加，如果添加失败了，则返回false.</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<p>​                                                                           </p>
<h3 id="ArrayBlockingQueue"><a href="#ArrayBlockingQueue" class="headerlink" title="ArrayBlockingQueue"></a>ArrayBlockingQueue</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> BlockingQueue&lt;String&gt; strs = <span class="keyword">new</span> <span class="title class_">ArrayBlockingQueue</span>&lt;&gt;(<span class="number">10</span>);</span><br></pre></td></tr></table></figure>


<p>对象的方法和上面的BlockingQueue是一样的，用法也是一样的。<br>二者的区别主要是：</p>
<ol>
<li>LinkedBlockingQueue是一个单向链表实现的阻塞队列，在链表一头加入元素，如果队列满，就会阻塞，另一头取出元素，如果队列为空，就会阻塞。</li>
<li>LinkedBlockingQueue内部使用ReentrantLock实现插入锁(putLock)和取出锁(takeLock)。</li>
</ol>
<p>相比于数组实现的ArrayBlockingQueue的有界情况，我们称之为有界队列，LinkedBlockingQueue可认为是无界队列。当然，也可以向上面那样指定队列容量，但是这个参数常常是省略的，多用于任务队列。</p>
<h3 id="DelayQueue"><a href="#DelayQueue" class="headerlink" title="DelayQueue"></a>DelayQueue</h3><p>DelayQueue也是一个BlockingQueue，其特化的参数是Delayed。<br>Delayed扩展了Comparable接口，比较的基准为延时的时间值，Delayed接口的实现类getDelay()的返回值应为固定值(final).DelayQueue内部是使用PriorityQueue实现的，即：</p>
<blockquote>
<p>DelayQueue &#x3D; BlockingQueue + PriorityQueue + Delayed</p>
</blockquote>
<p>可以说，DelayQueue是一个使用优先队列（PriorityQueue）实现的BlockingQueue，优先队列的比较基准值是时间。这是一个无界的BlockingQueue，用于放置实现了Delayed接口的对象，其中的对象只能在其到期时才能从队列中取走。这种队列是有序的，即队头对象的延迟到期时间最长。但是要注意的是，不能将null元素放置到这种队列中。<br>Delayed，一种混合风格的接口，用来标记那些应该在给定延迟时间之后执行的对象。此接口的实现类必须重写一个 compareTo() 方法，该方法提供与此接口的 getDelay()方法一致的排序。<br>DelayQueue存储的对象是实现了Delayed接口的对象，在这个对象中，需要重写compareTo()和getDelay()方法，例如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">MyTask</span> <span class="keyword">implements</span> <span class="title class_">Delayed</span> &#123;</span><br><span class="line"><span class="type">long</span> runningTime;</span><br><span class="line">MyTask(<span class="type">long</span> rt) &#123;</span><br><span class="line"><span class="built_in">this</span>.runningTime = rt;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compareTo</span><span class="params">(Delayed o)</span> &#123;</span><br><span class="line"><span class="keyword">if</span>(<span class="built_in">this</span>.getDelay(TimeUnit.MILLISECONDS) &lt;  o.getDelay(TimeUnit.MILLISECONDS))</span><br><span class="line"><span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(<span class="built_in">this</span>.getDelay(TimeUnit.MILLISECONDS) &gt; o.getDelay(TimeUnit.MILLISECONDS))</span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line"><span class="keyword">else</span> </span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">long</span> <span class="title function_">getDelay</span><span class="params">(TimeUnit unit)</span> &#123;</span><br><span class="line"><span class="keyword">return</span> unit.convert(runningTime - System.currentTimeMillis(), TimeUnit.MILLISECONDS);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>因此，当我们在main()函数中，向该队列加入元素后再取出元素的过程，就会存在延时，可以这样验证：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">long</span> <span class="variable">now</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line"><span class="type">MyTask</span> <span class="variable">t1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyTask</span>(now + <span class="number">1000</span>);</span><br><span class="line"><span class="type">MyTask</span> <span class="variable">t2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyTask</span>(now + <span class="number">2000</span>);</span><br><span class="line"><span class="type">MyTask</span> <span class="variable">t3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyTask</span>(now + <span class="number">1500</span>);</span><br><span class="line"><span class="type">MyTask</span> <span class="variable">t4</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyTask</span>(now + <span class="number">2500</span>);</span><br><span class="line"><span class="type">MyTask</span> <span class="variable">t5</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyTask</span>(now + <span class="number">500</span>);</span><br><span class="line">tasks.put(t1);</span><br><span class="line">tasks.put(t2);</span><br><span class="line">tasks.put(t3);</span><br><span class="line">tasks.put(t4);</span><br><span class="line">tasks.put(t5);</span><br><span class="line">System.out.println(tasks);</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;<span class="number">5</span>; i++) &#123;</span><br><span class="line">System.out.println(tasks.take());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注意：为了方便查看到效果，可以重写toString()函数，来保证打印出来的结果有意义：<br>例如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="string">&quot;&quot;</span> + runningTime;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>DelayQueue可以用在诸如用监控线程来轮询是否有超时任务出现，来处理某些具有等待时延的情况，这样，可以避免由于数量巨大造成的轮询效率差的问题。例如：</p>
<ol>
<li>关闭空闲连接：服务器中，有很多客户端的连接，空闲一段时间之后需要关闭他们。</li>
<li>缓存：缓存中的对象，超过了空闲时间，需要从缓存中移出。</li>
<li>任务超时处理：在网络协议滑动窗口请求应答式交互时，处理超时未响应的请求。</li>
</ol>
<h3 id="LinkedTransferQueue"><a href="#LinkedTransferQueue" class="headerlink" title="LinkedTransferQueue"></a>LinkedTransferQueue</h3><p>TransferQueue是一个继承了BlockingQueue的接口，并且增加若干新的方法。LinkedTransferQueue是TransferQueue接口的实现类，其定义为一个无界的队列，具有先进先出(FIFO)的特性。<br>TransferQueue接口含有下面几个重要方法：</p>
<ol>
<li>transfer(E e)<br>若当前存在一个正在等待获取的消费者线程，即立刻移交之；否则，会插入当前元素e到队列尾部，并且等待进入阻塞状态，到有消费者线程取走该元素。</li>
<li>tryTransfer(E e)<br>若当前存在一个正在等待获取的消费者线程（使用take()或者poll()函数），使用该方法会即刻转移&#x2F;传输对象元素e；若不存在，则返回false，并且不进入队列。这是一个不阻塞的操作。</li>
<li>tryTransfer(E e,long timeout,TimeUnit unit)<br>若当前存在一个正在等待获取的消费者线程，会立即传输给它;否则将插入元素e到队列尾部，并且等待被消费者线程获取消费掉；若在指定的时间内元素e无法被消费者线程获取，则返回false，同时该元素被移除。</li>
<li>hasWaitingConsumer()<br>判断是否存在消费者线程。</li>
<li>getWaitingConsumerCount()<br>获取所有等待获取元素的消费线程数量。</li>
<li>size()<br>因为队列的异步特性，检测当前队列的元素个数需要逐一迭代，无法保证原子性，可能会得到一个不太准确的结果，尤其是在遍历时有可能队列发生更改。<br>使用方法：</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">LinkedTransferQueue&lt;String&gt; strs = <span class="keyword">new</span> <span class="title class_">LinkedTransferQueue</span>&lt;&gt;();<span class="comment">//实例化</span></span><br></pre></td></tr></table></figure>


<p>如果当前没有消费者线程(存在take方法的线程):</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">strs.transfer(<span class="string">&quot;aaa&quot;</span>);</span><br></pre></td></tr></table></figure>


<p>该方法会一直阻塞在这里，知道有消费者线程存在。<br>而如果使用传统的put()方法来加入元素的话，则不会发生阻塞现象。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">strs.take()</span><br></pre></td></tr></table></figure>


<p>同样，获取队列中元素的方法take()也是阻塞在这里等待获取新的元素的。</p>
<h3 id="SynchronousQueue"><a href="#SynchronousQueue" class="headerlink" title="SynchronousQueue"></a>SynchronousQueue</h3><p>SynchronousQueue也是一种BlockingQueue，是一种无缓冲的等待队列。所以，在某次添加元素后必须等待其他线程取走后才能继续添加；可以认为SynchronousQueue是一个缓存值为0的阻塞队列(也可以认为是1)，它的isEmpty()方法永远返回是true，remainingCapacity()方法永远返回是0.<br>remove()和removeAll() 方法永远返回是false，iterator()方法永远返回空，peek()方法永远返回null.<br>在使用put()方法时，会一直阻塞在这里，等待被消费:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">BlockingQueue</span> <span class="variable">strs</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SynchronousQueue</span>&lt;&gt;();<span class="comment">//实例化</span></span><br><span class="line">strs.put(“aaa”); <span class="comment">//阻塞等待消费者消费</span></span><br><span class="line">strs.add(“aaa”);<span class="comment">//会产生异常，提示队列满了</span></span><br><span class="line">strs.take();<span class="comment">//该方法可以取出元素，同样是阻塞的，需要在线程中去实现他，作为消费者.</span></span><br></pre></td></tr></table></figure>

<p>原文链接：<a target="_blank" rel="noopener" href="https://blog.csdn.net/wang7807564/article/details/80048576">https://blog.csdn.net/wang7807564/article/details/80048576</a></p>
<hr>
<p>完</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




  <nav class="pagination">
    <a class="extend prev" rel="prev" title="上一页" aria-label="上一页" href="/page/30/"><i class="fa fa-angle-left"></i></a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/30/">30</a><span class="page-number current">31</span><a class="page-number" href="/page/32/">32</a><span class="space">&hellip;</span><a class="page-number" href="/page/60/">60</a><a class="extend next" rel="next" title="下一页" aria-label="下一页" href="/page/32/"><i class="fa fa-angle-right"></i></a>
  </nav>

</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">

  <div class="copyright">
    &copy; 
    <span itemprop="copyrightYear">2025</span>
    <span class="with-love">
      <i class="fa fa-heart"></i>
    </span>
    <span class="author" itemprop="copyrightHolder">胡方雷</span>
  </div>
<div class="wordcount">
  <span class="post-meta-item">
    <span class="post-meta-item-icon">
      <i class="fa fa-chart-line"></i>
    </span>
      <span>站点总字数：</span>
    <span title="站点总字数">1.8m</span>
  </span>
  <span class="post-meta-item">
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
      <span>站点阅读时长 &asymp;</span>
    <span title="站点阅读时长">26:40</span>
  </span>
</div>
<div class="busuanzi-count">
    <span class="post-meta-item" id="busuanzi_container_site_uv">
      <span class="post-meta-item-icon">
        <i class="user"></i>
      </span>
      <span class="site-uv" title="总访客量">
        <span id="busuanzi_value_site_uv"></span>
      </span>
    </span>
    <span class="post-meta-item" id="busuanzi_container_site_pv">
      <span class="post-meta-item-icon">
        <i class="eye"></i>
      </span>
      <span class="site-pv" title="总访问量">
        <span id="busuanzi_value_site_pv"></span>
      </span>
    </span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/" rel="noopener" target="_blank">NexT.Gemini</a> 强力驱动
  </div>

    </div>
  </footer>

  
  <div class="toggle sidebar-toggle" role="button">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>
  <div class="sidebar-dimmer"></div>
  <div class="back-to-top" role="button" aria-label="返回顶部">
    <i class="fa fa-arrow-up fa-lg"></i>
    <span>0%</span>
  </div>

  <a href="https://github.com/hufanglei" class="github-corner" title="在 GitHub 上关注我" aria-label="在 GitHub 上关注我" rel="noopener" target="_blank"><svg width="80" height="80" viewBox="0 0 250 250" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg></a>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


  
  <script src="https://cdnjs.cloudflare.com/ajax/libs/animejs/3.2.1/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous"></script>
<script src="/js/comments.js"></script><script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/sidebar.js"></script><script src="/js/next-boot.js"></script>

  <script src="https://cdnjs.cloudflare.com/ajax/libs/hexo-generator-searchdb/1.4.1/search.js" integrity="sha256-1kfA5uHPf65M5cphT2dvymhkuyHPQp5A53EGZOnOLmc=" crossorigin="anonymous"></script>
<script src="/js/third-party/search/local-search.js"></script>







  
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>





</body>
</html>
